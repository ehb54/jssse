<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"SASMOL JS_sasmol.js.html":{"id":"SASMOL JS_sasmol.js.html","title":"Source: SASMOL JS/sasmol.js","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Source: SASMOL JS/sasmol.js /** * @fileoverview Class Definition and basic I/O for reading/writing PDB files * * @requires NPM:numjs * @requires NPM:sprintf-js */ /** * @module SasMol */ //DEPENDENCIES: //import numJS (like numpy) var nj = require('numjs'); //import string formatter var sprintf = require(&quot;sprintf-js&quot;).sprintf, vsprintf = require(&quot;sprintf-js&quot;).vsprintf; /** * SasMol Class definition * @namespace * @prop {Object} data holder of all relevant PDB data * @prop {Number[]} data.atom array of atom serial numbers * @prop {Number[]} data.index (UNDEFINED) * @prop {Number[]} data.original_index (UNDEFINED) * @prop {String[]} data.name atom name * @prop {String[]} data.loc loc * @prop {String[]} data.resname Residue name * @prop {String[]} data.chain Chain id * @prop {Number[]} data.resid residue sequence number * @prop {String[]} data.rescode iCode * @prop {Object} data.coor numjs array * @prop {Object} data.coorObj object for storing coor xyz easier (than numjs) * @prop {Number[]} data.occupancy occupancy * @prop {Number[]} data.beta temp. factor * @prop {String[]} data.segname segment name * @prop {String[]} data.element element name * @prop {String[]} data.charge charge * * @prop {String[]} data.moltype (UNDEFINED) * @prop {Object} data.conect (UNDEFINED) * @prop {String[]} data.residue_flag (UNDEFINED) * @prop {String[]} data.original_resid (UNDEFINED) * @prop {String[]} data.header (UNDEFINED) */ var SasMol = { //initialize fields data : { atom:[] , //atom serial number index:[] , original_index:[] , name:[] , //atom name loc:[] , //altloc resname:[] , //resname chain:[] , //chain id resid:[] , //residue seq number 23-26 rescode:[], //icode coor: [],//xyz coorObj:{}, occupancy:[] , //occupancy beta:[] , //temp factor segname:[] , //segname element:[] , //elt symbol charge:[] , //charge //other moltype:[] , conect : {}, residue_flag : [] , original_resid:[] , header : [] } }; /** * atom setter * @param {Number[]} atom atom array to set */ SasMol.atom = function(atom){ this.data.atom = atom; } /** * atom getter * @return {Number[]} atom array to get */ SasMol.getAtom = function(){ return this.data.atom; } /** * index setter * @param {Number[]} index index array to set */ SasMol.index = function(index){ this.data.index = index; } /** * index getter * @return {Number[]} index array to get */ SasMol.getIndex = function(){ return this.data.index; } /** * origIndex setter * @param {Number[]} index origIndex array to set */ SasMol.origIndex = function(index){ this.data.original_index = index; } /** * origIndex getter * @return {Number[]} origIndex array to get */ SasMol.getOrigIndex = function(){ return this.data.original_index; } /** * name setter * @param {String[]} name name array to set */ SasMol.name = function(name){ this.data.name = name; } /** * name getter * @return {String[]} name array to get */ SasMol.getName = function(){ return this.data.name; } /** * loc setter * @param {String[]} loc loc array to set */ SasMol.loc = function(loc){ this.data.loc = loc; } /** * loc getter * @return {String[]} loc array to set */ SasMol.getLoc = function(){ return this.data.loc; } /** * resname setter * @param {String[]} resname resname array to set */ SasMol.resname = function(resname){ this.data.resname = resname; } /** * resname getter * @return {String[]} resname array to get */ SasMol.getResname = function(){ return this.data.resname; } /** * chain setter * @param {String[]} chain chain id array to set */ SasMol.chain = function(chain){ this.data.chain = chain; } /** * chain getter * @return {String[]} chain id array to get */ SasMol.getChain = function(){ return this.data.chain; } /** * resID setter * @param {Number[]} id res id array to set */ SasMol.resID = function(id){ this.data.resid = id; } /** * resID getter * @return {Number[]} res id array to get */ SasMol.getResID = function(){ return this.data.resid; } /** * rescode setter * @param {String[]} rescode rescode array to set */ SasMol.rescode = function(rescode){ this.data.rescode = rescode; } /** * rescode getter * @return {String[]} rescode rescode array to get */ SasMol.getRescode = function(){ return this.data.rescode; } /** * coor setter * @param {Object} coor coor array to set */ SasMol.coor = function(coor){ this.data.coor = coor; } /** * coor getter * @return {Object} coor array to get */ SasMol.getCoor = function(){ return this.data.coor; } /** * coorObj setter * @param {Object} coorObj coorObj array to set */ SasMol.coorObj = function(coor){ this.data.coorObj = coor; } /** * coorObj getter * @return {Object} coorObj array to get */ SasMol.getCoorObj = function(){ return this.data.coorObj; } /** * occupancy setter * @param {Number[]} occupancy occupancy array to set */ SasMol.occupancy = function(occ){ this.data.occupancy = occ; } /** * occupancy getter * @return {Number[]} occupancy array to get */ SasMol.getOccupancy = function(){ return this.data.occupancy; } /** * beta setter * @param {Number[]} beta beta array to set */ SasMol.beta = function(beta){ this.data.beta = beta; } /** * beta getter * @return {Number[]} beta beta array to get */ SasMol.getBeta = function(){ return this.data.beta; } /** * elt setter * @param {String[]} elt elt array to set */ SasMol.elt = function(elt){ this.data.element = elt; } /** * elt getter * @return {String[]} elt array to get */ SasMol.getElt = function(){ return this.data.element; } /** * charge setter * @param {String[]} charge charge array to set */ SasMol.charge = function(charge){ this.data.charge = charge; } /** * charge getter * @return {String[]} charge array to get */ SasMol.getCharge = function(){ return this.data.charge; } /** * segname setter * @param {String[]} segname segname array to set */ //segname SasMol.segname = function(segname){ this.data.segname = segname; } /** * segname getter * @return {String[]} segname array to get */ SasMol.getSegname = function(){ return this.data.segname; } //SASMOL IO /** * Reads PDB Asynchronously * @param {string} inputStr file * * @returns {string} full file as string */ SasMol.readPDB = function(inputStr){ var linesArr = inputStr.split('\\n').filter(Boolean); //console.log(linesArr); var linesArrLen = linesArr.length; //Sasmol load properties and local variables: var atomArr = [] ; //atom serial number var indexArr = [] ; var original_indexArr = [] ; var nameArr = [] ; //atom name var locArr = [] ; //altloc var resnameArr = [] ; //resname var chainArr = [] ; //chain id var residArr = [] ; //residue seq number 23-26 var rescodeArr = []; //icode var x = []; var y = []; var z = []; var coor = [];// defined below var occupancyArr = [] ; //occupancy var betaArr = [] ; //temp factor var segnameArr = [] ; //segname var elementArr = [] ; //elt symbol var chargeArr = [] ; //charge var fileStr = &quot;&quot;; var frameCount = 1; var atomCount = 0; var errCount = 0; var errors = &quot;&quot;; coor = nj.zeros([frameCount, atomCount, 3], 'float32'); //console.log(coor); for(var i = 0; i&lt;linesArrLen;i++){ var atomCheck = /^ATOM\\s/; var atomParse = /^ATOM\\s{2}(.{5})\\s(.{4})(.)(.{3})\\s(.)(.{4})(.)\\s{3}(.{8})(.{8})(.{8})(.{6})(.{6})\\s{6}(.{4})(.{2})(.{2})/g; if(atomCheck.test(linesArr[i])){ var result = atomParse.exec(linesArr[i]); //console.log(result); //if regex can't match, format is incorrect so throw error if(result == null){ //is this the right error? errors += &quot;Lines in PDB file has incorrect length (line &quot; + i + ')\\n'; } //else assign properties to SASMOL object else{ //append to return string fileStr = fileStr + linesArr[i] + &quot;\\n&quot;; //trim spaces (inside else block or else result length undefined error gets returned) for(var j = 0;j&lt;result.length;j++){ result[j] = result[j].trim(); } if(isNaN(parseInt(result[1]))){ errors += &quot;Line &quot; + i + &quot;has invalid atom number\\n&quot;; } else{ atomArr.push(parseInt(result[1])); } nameArr.push(result[2]); locArr.push(result[3]); resnameArr.push(result[4]); chainArr.push(result[5]); residArr.push(parseInt(result[6])); rescodeArr.push(result[7]); //coor x.push(parseFloat(result[8])); y.push(parseFloat(result[9])); z.push(parseFloat(result[10])); var coorObj = {x: parseFloat(result[8]), y: parseFloat(result[9]), z: parseFloat(result[10])}; //coor.push(coorObj); occupancyArr.push(parseFloat(result[11])); betaArr.push(parseFloat(result[12])); elementArr.push(result[14]); chargeArr.push(result[15]); segnameArr.push(result[13]); //use setters this.atom(atomArr); this.name(nameArr); this.loc(locArr); this.resname(resnameArr); this.chain(chainArr); this.resID(residArr); this.rescode(rescodeArr); this.occupancy(occupancyArr); this.beta(betaArr); this.elt(elementArr); this.charge(chargeArr); this.segname(segnameArr); } } } for(var i = 0;i&lt;frameCount;i++){ for(var j = 0;j&lt;atomCount;j++){ //set x coor.set(i,j,0,x[j]); //set y coor.set(i,j,1,y[j]); //set z coor.set(i,j,2,z[j]); } } this.coor(coor); //use numjs coor for data storage, coorObj as alternative for accessing xyz fields easier var coorObj = {x: x, y: y, z: z}; this.coorObj(coorObj); return fileStr; } /** * writes PDB (not to file, but returns string) * * @returns {string} full file as string */ //return string instead of console logging SasMol.writePDB = function(){ var numAtoms = this.data.atom.length; var fileStr = &quot;&quot;; //debugging //console.log(&quot; 1 2 3 4 5 6 7 \\n&quot;); //console.log(&quot;01234567890123456789012345678901234567890123456789012345678901234567890123456789\\n&quot;); for(var i = 0; i&lt;numAtoms;i++){ fileStr += vsprintf(&quot;%-6s%5s %-4s%1s%-4s%1s%4s%1s %8s%8s%8s%6s%6s %-4s%2s%2s\\n&quot;, [&quot;ATOM&quot;,this.getAtom()[i],this.getName()[0],this.getLoc()[0],this.getResname()[0],this.getChain()[0],this.getResID()[0],this.getRescode()[0],this.getCoorObj().x[0].toFixed(3),this.getCoorObj().y[0].toFixed(3),this.getCoorObj().z[0].toFixed(3),this.getOccupancy()[0].toFixed(2),this.getBeta()[0].toFixed(2),this.getSegname()[0],this.getElt()[0],this.getCharge()[0]]); } //console.log(fileStr); return fileStr; } module.exports = {SasMol}; × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"jssse.js.html":{"id":"jssse.js.html","title":"Source: jssse.js","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Source: jssse.js /** * @fileoverview Class Definition of JSSSE, bobj, and sobj */ /** * @module JSSSE */ //bring in SasMol (bundled with browserify) - use to do pdb parsing here instead of main widgetJS.js file? var SasMol = require('./SASMOL\\ JS/sasmol.js'); /** * bobj definition (doesn't really matter what values are initialized to the fields because everything is loosely defined in JS) * @namespace * @property {string} id value passed to jssse.createBoard() and used as the parent DOM element for display * @property {number} columns number of sobjs to display per row * @property {sobj[]} sobjs collection of references of child sobjs * @property {event[]} events the array of pending events * @property {event[]} undo the array of events used for undo and redo * @property {number} undoPos position of current state in undo array * @property {boolean} busy set if events are processing * @property {number} sobjIndex index of sobj to be created (next) */ var bobj = { id : &quot;&quot;, columns : 0, sobjs : [], events : [{}], undo : [{}], undoPos : 0, busy : true, sobjIndex : 0 } /** * sobj definition * @namespace * @property {string} id id value passed to jssse.createSobj() and used internally to keep track of the structure object * @property {string} source loaded source tag from last jssse.load() * @property {Object} data internal representation of structure data * @property {bool} valid set to true if the load is complete * @property {bobj} bobj references parent bobj * @property {Object} options current options * @property {SasMol} sasmol attached sasmol object */ var sobj = { id : &quot;&quot;, source : &quot;&quot;, data : {}, valid : false, bobj : {}, options : {}, sasmol : {} } /** * JSSSE Object definition * @namespace */ var jssse = { //properties?? } /** * creates a bobj object associated with the given DOM id * @memberof jssse * @param {string} id DOM id * @param {Object} options an object with option properties * @prop {number} columns number of sobjs to display per row * @prop {boolean} enableLoad determines whether or not a &quot;load&quot; button will be displayed to load a new structure directly into the board * @return {bobj} the bobj which will hold all the state info for this board object */ jssse.createBoard = function( id, options) { //default values (detailed in API) options.columns = 2; enableLoad = false; //create bobj var newbobj = Object.create(bobj); newbobj.id = id; newbobj.options = options; return newbobj; } /** * removes a bobj * @param {bobj} bobj a bobj previously returned form bojb.createBoard */ jssse.remove = function( bobj ){ //standard practice for 'removing'? bobj = null } /** * undoes operations in the undo/redo stack * @param {bobj} bobj the bobj to be operated on, returned previously from a jssse.createBoard() call * @param {number} n optional number of steps to undo, 1 default, -1 undo to beginning * @param {Function} cb callback when operation is complete, returns err if undo count n is more than available */ jssse.undo = function( bobj, n, cb ){ //UNDER DEVELOPMENT } /** * redoes operations in the undo/redo stack * @param {bobj} bobj the bobj to be operated on, returned previously from a jssse.createBoard() call * @param {number} n optional number of steps to redo, 1 default, -1 redo to beginning * @param {Function} cb callback when operation is complete, returns err if redo count n is more than available */ jssse.redo = function( bobj, n, cb ){ } /** * internal function to add an event to event stack (stored in sobj, separate from undo/redo stack) called by every event (mouse click, text entry etc) pushes eventObj to the bobj event stack and the undo/redo stack of bobj (as identified in eventObj) calls jssse.processEvents( bobj ) * @param {bobj} bobj the bobj to be operated on, returned from a jssse.createBoard() call * @param {event} eventObj object produced by event handler * @prop {sobj} sobj the sobj for the event * @prop {string} type the type of event: select, remove, edit ?? * @prop {boolean} canUndo set if this event causes a change which can be undone (optional) * @prop {HTML_NODE[]} selected required types: select, remove ?? * @prop {boolean} undo set by jssse.undo() to specify events that are to be undone * @prop {Function} cb call back function when event is finished, called with ( err, eventObj ) */ jssse.newEvent = function( bobj, eventObj ){ // UNDER DEVELOPMENT } /** * internal function to process the event stack returns immediately if no unprocessed events present or if event processing flag is set marks object event processing flag process oldest event off event stack calls whatever is needed to handle the event, e.g. screen updates etc. when all callbacks complete, unmark object event processing flag, return jssse.processEvents( obj ) * @param {bobj} bobj the bobj to be operated on, returned from a jssse.createBoard() call */ jssse.processEvents = function( bobj ){ // UNDER DEVELOPMENT // } /** * returns a complete object which can be saved with the complete state * @param {bobj} bobj bobj : the bobj to be operated on * @return {bobj} bdata : a deep copy of the bobj suitable for saving */ jssse.toBdata = function( bobj ){ // UNDER DEVELOPMENT } /** * loads data previously serialized and creates a new bobj * @param {string} id DOM id to create bobj * @param {bobj} bdata bdata : a deep copy of a bobj previously returned from jssse.toBdata() * @return {bobj} bobj: the bobj */ jssse.loadBobj = function( id, bdata ){ //UNDER DEVELOPMENT } /** * d88b .d8888. .d8888. .d8888. d88888b .88b d88. d88888b d888888b db db .d88b. d8888b. .d8888. `8P' 88' YP 88' YP 88' YP 88' 88'YbdP`88 88' `~~88~~' 88 88 .8P Y8. 88 `8D 88' YP 88 `8bo. `8bo. `8bo. 88ooooo 88 88 88 88ooooo 88 88ooo88 88 88 88 88 `8bo. 88 `Y8b. `Y8b. `Y8b. 88~~~~~ 88 88 88 88~~~~~ 88 88~~~88 88 88 88 88 `Y8b. db. 88 db 8D db 8D db 8D 88. 88 88 88 88. 88 88 88 `8b d8' 88 .8D db 8D Y8888P `8888Y' `8888Y' `8888Y' Y88888P YP YP YP Y88888P YP YP YP `Y88P' Y8888D' `8888Y' */ /** * creates a sobj object attached to the given bobj * @param {bobj} bobj a bobj previously returned from bobj.createBoard * @param {id} id a unique DOM id for this sobj * @param {Object} options an object with options as defined below * @prop {boolean} readonly flag to determine whether or not the sobj is editable * @return {sobj} the sobj which will hold all the state info for this structure object */ jssse.createSobj = function( bobj, id, options ){ var newSobj = Object.create(sobj); newSobj.id = id; newSobj.options = options; newSobj.bobj = bobj; //push to bobj? bobj.sobjs[bobj.sobjIndex] = newSobj; //increment index so next sobj created will be pushed to the right index of the sobjs array bobj.sobjIndex++; return newSobj; } /** * updates options in sobj - keep in mind merges, options altered by other windows, depth * @param {sobj} sobj an sobj previously returned from a jssse.createSobj() call * @param {Object} options an object with option properties as defined in jssse.createSobj() above * @param {Function} cb [description] */ jssse.update = function( sobj, options, cb ){ } /** * return options of sobj, likely just return sobj.options; * @param {sobj} sobj an sobj previously returned from a jssse.createSobj() call * @return {Object} options : the options object as defined in jssse.createSobj() */ jssse.options = function( sobj ){ return sobj.options; } /** * loads the data into the object and displays * @param {sobj} sobj an sobj previously returned from a jssse.createSobj() call * @param {string} data a PDB in text, or a PDB file reference, e.g. &quot;file://path/to/pdb&quot; or &quot;http://server/path/to/file&quot; or &quot;rcsb:1XYZ&quot; etc. * @param {Object} loadOptions an optional object describing loadOptions as described below * @prop {string} type the type of data, such as pdb, pdbx, ... * @param {Function} cb callback function when load finishes or fails due to error * @return {string} throw error? */ jssse.load = function( sobj, data, loadOptions, cb){ //CODE TO DO STUFF WITH LOADOPTIONS (not well-defined in API) //use regex's to detect if file:// or https:// //local files can only be loaded through INPUT (vanilla JS) - SasMol does this var regex = /(.{4})/; if(regex.exec(data)[0] == 'http'){ //retrieve file from pdb database $.get(data, function(info){ //do something with info (assign to data property) sobj.data = info; //console.log(info); }) .fail(function(err){ console.log('error occured!'); }); } //else assume data is in PDB text (not an address) else{ sobj.data = data; } //execute cb when load finishes cb(); } /** * returns the data (possibly edited by the user) in various formats * @param {sobj} sobj an sobj previously returned from a jssse.createSobj() call * @param {Object} outOptions an optional object describing outOptions as described below * @prop {string} type the type of data, such as pdb, pdbx, ... * @return {Object} the data of the object in the specified format */ jssse.out = function( sobj, outOptions ){ var data = sobj.data; //UNDER DEVELOPMENT //LOGIC TO MODIFY DATA WITH OUTOPTIONS return data; } /** * returns new object after merging objects (variadic function). Be careful with options (??) * @param {sobj} sobj1 variable number of sobjs previously returned from jssse.createSobj() calls * @param {sobj} sobj2 * @return {sobj} new built sobj if successful, error if failure */ jssse.build = function( sobj1, sobj2 ){ var sobj; //UNDER DEVELOPMENT //BUILD - what does it mean to build? combine arrays? what properties should be merged? return sobj; } /** * returns an array of objects copied (new instances created with properties copied over) * @param {sobj} sobj an sobj to be copied, returned previously from a jssse.createSobj() call * @param {number} n number times to be copied * @return {sobj[]} array of newly named (new id'd) sobjs also associated with the parent bobj */ jssse.copy = function( sobj, n ){ //UNDER DEVELOPMENT } module.exports = {bobj, jssse, sobj}; × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"widgetJS.js.html":{"id":"widgetJS.js.html","title":"Source: widgetJS.js","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Source: widgetJS.js //running jsdoc command in terminal: // jsdoc -c ./conf.json -d ../docs -R ../README.md -t ./node_modules/ink-docstrap/template /** * @fileoverview Manages html display of widget and corresponding functionalities * @requires JSSSE * @requires SasMol */ //bring in definitions (SASMOL and JSSSE) //Sasmol is exported like so: {SasMol}; therefore, use SasMol (this file's variable) .SasMol (to access the actual SasMol class object) var SasMol = require('./SASMOL\\ JS/sasmol.js'); //likewise, use JSSSE.jssse.[jssse-defined methods] to correctly access the JSSSE methods //same applies for JSSSE.bobj.[bobj methods] or JSSSE.sobj.[sobj methods] var JSSSE = require('./jssse'); //disable right-click on page window.addEventListener('contextmenu', function (e) { // Not compatible with IE &lt; 9 e.preventDefault(); }, false); //shorthand for $(document).ready(function(){ //CODE}) $( function() { /************************************************************************** __ __ __ __ _ _ ( \\/ ) ( ) ( )( \\( ) ) ( /__\\ )( ) ( (_/\\/\\_)(_)(_)(__)(_)\\_) *************************************************************************/ var readBool = false; //flags var numPDB = 0; //global var for number of PDB's (read) var loadBool = false; //(debugging purposes - may be important in the future) var numAtomsArr = []; //global array for storing how many atoms per pdb (access with sobjIndex) //TESTING - create JSSSE/bobj/sobjs at pleasure var jssseArr = []; //stores sobjs /** * bobj object * @name newBobj * @type {module:JSSSE~bobj} * */ var newBobj = JSSSE.jssse.createBoard( 'board0', {}); /** * sobj object * @name testSobj * @type {module:JSSSE~sobj} * */ var testSobj = JSSSE.jssse.createSobj( newBobj, 'sobj0'); //DEMO // console.log(bobj); // console.log(testSobj); jssseArr[0] = testSobj; /** * use Promises to wait until async operation is finished (initialize + populate windows correctly) src: https://stackoverflow.com/questions/41906697/how-to-determine-that-all-the-files-have-been-read-and-resolve-a-promise/ * @name readFile(file) * @func * @param {File} file file object */ function readFile(file) { return new Promise(function(resolve, reject) { var reader = new FileReader(); reader.onload = function(e) { resolve(e.target.result); }; reader.onerror = reader.onabort = reject; reader.readAsText(file); }); } /** * use promises to wait until async operation is finished, calls helper method readFile * @name readmultifiles * @func * @param {File[]} files array of file objects (different than FileList object) * @return {string[]} array of files read (in literal text) */ function readmultifiles(files) { var results = []; files.reduce(function(p, file) { return p.then(function() { return readFile(file).then(function(data) { // put this result into the results array results.push(data); }); }); }, Promise.resolve()).then(function() { // make final resolved value be the results array // DEMO //console.log(results); //populate JSSSE objects and canvas windows readBool = true; numPDB = results.length; var info = &quot;&quot;; for(var i = 0; i&lt;numPDB;i++){ //info contains literal text from file info = results[i]; /** * sasmol object * @type {module:SasMol~SasMol} * */ jssseArr[i].sasmol = Object.create(SasMol.SasMol); //store read information inside jssse objects jssseArr[i].sasmol.readPDB(info); numAtomsArr[i] = jssseArr[i].sasmol.getAtom().length; } //DEMO console.log(jssseArr); for(var i = 0; i&lt;numPDB;i++){ populateWindows(jssseArr[i].id, jssseArr[i].sasmol); initialize('start', jssseArr[i].sasmol,i); } return results; }); } /** * main function triggered by event - calls multifiles to parse files * @name handleRead * @func * @param {event} e event object - use to extract files */ function handleRead(e){ var files = e.target.files; var fileArr = []; //convert fileList to array of files for(var i = 0,f;f=files[i];i++){ fileArr[i]=f; } readmultifiles(fileArr); } //listen to when user inputs file(s) (event is triggered once user inputs file(s)) document.getElementById('files').addEventListener('change', handleRead, false); /* ____ ____ _ _ ____ __ __ ____ ____ ____ ___ __ ____ ____ ( \\( __)/ )( \\( __)( ) / \\( _ \\( __)( _ \\ / __)/ \\( \\( __) ) D ( ) _) \\ \\/ / ) _) / (_/\\( O )) __/ ) _) ) / ( (__( O )) D ( ) _) (____/(____) \\__/ (____)\\____/ \\__/(__) (____)(__\\_) \\___)\\__/(____/(____) */ // GLOBAL VARIABLES FOR keeping track of HTML within (potentially) multiple SOBJ's //access DOM elt's by classname (not id because they are not unique - multiple selects) var widgetContainerArr = []; var seqContainerArr = []; var seqDivArr = []; var locatorDivArr = []; var locatorBoxArr = []; var seqDivWidthArr = []; var zoomDivArr = []; // var seqSelDivArr = []; //for future reference? var seqSelRangeDivArr = []; var eltWidthArr = []; var dsArr = []; var zoomdsArr = []; var seqObjArr = []; //Master array for all sequence objects var currentZoomedWidget; // var aminoAcidArr = [ // 'ala', 'arg', 'asn', 'asp', 'cys', 'gln', 'glu', 'gly', 'his','ile','leu','lys', 'met', 'phe', 'pro', 'ser', 'thr','trp', 'tyr', 'val' // ]; var eltWidth; var zoomPress = false; //flag for pressing zoom var seqDivFlag = false; //flag for entering sequence Div (toggles on marker and locatorDiv) //CREATE SEQUENCE OBJECT //makes sobj's jquery-sortable (replacable when dragged over each other) $(&quot;.board&quot;) .sortable({ items: &quot;.sortable&quot;, placeholder: 'SSE placeholder', forceHelperSize: true, tolerance:'pointer', handle: '.handle', scroll: false, cursor: 'move' }); var closeButtons = document.getElementsByClassName('close'); //ADD EVENT LISTENERS TO DO THINGS WITH CLOSE BUTTON /** * Populates windows attached to sobj's (all HTML necessary for sequence divs, feedback box, zoom div) * @name populateWindows * @function * @param {String} sobjID [dom ID of sobj] * @param {sasmol} object sasmol object */ function populateWindows(sobjID, object){ //console.log(sobjID); var sobjContent = document.getElementById(sobjID+' content'); //create div elt's for(var i = 0; i &lt; numPDB; i++){ var sobjIndex = i; //main sequence display var widgetContainer = document.createElement('div'); //widgetContainer.style.textAlign = 'center'; widgetContainer.classList.add('widget-container'); widgetContainer.id = 'widget-container'+sobjIndex; //widgetContainer.style.position = 'absolute'; var sequenceContainer = document.createElement('div'); sequenceContainer.classList.add('sequenceContainer'); //sequenceContainer.style.position = 'relative'; var sequenceDiv = document.createElement('div'); sequenceDiv.classList.add('sequenceDiv'); sequenceDiv.id = 'sequenceDiv'+sobjIndex; sequenceDiv.tabIndex = '0'; var sequenceDivHeader = document.createElement('p'); sequenceDivHeader.style.margin = '5px'; sequenceDivHeader.style.fontSize = '12px'; var headerText = document.createTextNode('SEQUENCE SELECTION BOX:'); sequenceDivHeader.appendChild(headerText); var marker = document.createElement('div'); marker.classList.add('marker'); var customSelector = document.createElement('div'); customSelector.classList.add('customSelector'); customSelector.style.height= '100%'; var locatorDiv = document.createElement('div'); locatorDiv.classList.add('locatorDiv'); var locatorBox = document.createElement('div'); locatorBox.classList.add('locatorBox'); var zoomDiv = document.createElement('div'); zoomDiv.classList.add('zoomDiv'); locatorDiv.appendChild(locatorBox); sequenceDiv.appendChild(marker); sequenceDiv.appendChild(customSelector); sequenceDiv.appendChild(locatorDiv); // sequenceDiv.appendChild(customSelector); sequenceContainer.appendChild(sequenceDiv); sequenceContainer.appendChild(zoomDiv); var sequenceSelInfoDiv = document.createElement('div'); sequenceSelInfoDiv.classList.add('sequenceSelInfoDiv'); sequenceSelInfoDiv.style.display = 'inline-block'; sequenceSelInfoDiv.style.textAlign = 'center'; var div = document.createElement('div'); var title = document.createElement('strong'); var titleText = document.createTextNode('CURRENT SELECTION'); title.appendChild(titleText); var div2 = document.createElement('div'); div2.style.textAlign = 'center'; var clearSelBtn = document.createElement('button'); clearSelBtn.classList.add('clearSelection'); var clearSelBtnText = document.createTextNode('Clear Selection'); var startSpan = document.createElement('span'); var startText = document.createTextNode('START '); var startIndex = document.createElement('span'); startIndex.classList.add('startIndex'); var endSpan = document.createElement('span'); var endText = document.createTextNode(' : END '); var endIndex = document.createElement('span'); endIndex.classList.add('endIndex'); var selectDisplay = document.createElement('div'); selectDisplay.classList.add('selectDisplay'); var selectDisplayRange = document.createElement('div'); selectDisplayRange.classList.add('selectDisplayRange'); selectDisplay.appendChild(selectDisplayRange); sequenceSelInfoDiv.appendChild(div); clearSelBtn.appendChild(clearSelBtnText); div2.appendChild(clearSelBtn); div.appendChild(title); div.appendChild(div2); startSpan.appendChild(startText); div.appendChild(startSpan); div.appendChild(startIndex); endSpan.appendChild(endText); div.appendChild(endSpan); div.appendChild(endIndex); div.appendChild(selectDisplay); widgetContainer.appendChild(sequenceSelInfoDiv); widgetContainer.appendChild(sequenceDivHeader); widgetContainer.appendChild(sequenceContainer); //append to sobj (top-level HTML elt) sobjContent.appendChild(widgetContainer); //EVENT LISTENERS //add clear selection functionality clearSelBtn.addEventListener('click',function(e){ clearAllSelection(sobjIndex); }); //add marker to follow mouse in div sequenceDiv.addEventListener('mousemove', function(e){ seqDivFlag = true; var seqDivPosition = getPosition(sequenceDiv); //debugging //console.log('mousein '+ (e.pageX - seqDivPosition.x)); marker.style.display = 'block'; marker.style.left = (e.pageX - seqDivPosition.x)+'px'; locatorBox.style.display = 'inline-block'; //only display locator if there's a valid PDB being read if(readBool){ //refer to helper function to geometrically get sequence index displayLocator(getIndexByWidth(e.pageX - seqDivPosition.x, sobjIndex), sobjIndex); } }); sequenceDiv.addEventListener('mouseleave',function(e){ seqDivFlag = false; //console.log('mouseout '+e.clientX); marker.style.display = 'none'; locatorDiv.style.display = 'none'; }); //listen to right-click sequenceDiv.addEventListener('contextmenu',function(e){ sequenceDiv.focus(); }); //what to do when update is clicked - make copy of current selection into a jQuery-droppable object document.getElementsByClassName('btn update')[0].addEventListener('click', function(e){ //clear seqPieces first $('#seqPiece'+sobjIndex).remove(); $('#drop'+sobjIndex).remove(); //DEMO // console.log(JSON.stringify(arrDisp)); var seqPiece = document.createElement('div'); seqPiece.classList.add('seqPiece'); seqPiece.id = 'seqPiece'+sobjIndex; var text = document.createTextNode(JSON.stringify(arrDisp)); seqPiece.appendChild(text); sobjContent.appendChild(seqPiece); var dropDiv = document.createElement('div'); dropDiv.classList.add('drop'); dropDiv.id = 'drop'+sobjIndex; document.getElementById('builder-canvas').appendChild(dropDiv); $('.drop').droppable({ tolerance: 'intersect', drop: function(event, ui) { var drop_p = $(this).offset(); var drag_p = ui.draggable.offset(); var left_end = drop_p.left - drag_p.left + 1; var top_end = drop_p.top - drag_p.top + 1; ui.draggable.animate({ top: '+=' + top_end, left: '+=' + left_end }); } }); $('#seqPiece'+sobjIndex).draggable({ revert: 'invalid', scroll: false, stack: &quot;.seqPiece&quot; }); }); //MAKE MODULAR + ADD MORE ELEMENTS var sasmolInfoDiv = document.createElement('div'); sasmolInfoDiv.style.position = 'absolute'; sasmolInfoDiv.style.top = '430px'; //MAKE RESPONSIVE/DYNAMIC /** * populates Sasmol info div - refer to object definition below to know what to pass as parameter * also handles display toggling (via checkbox eventlistener) * @name populateSasMolInfo * @func * @param {sasmolInfo} param sasmol info object (definied below) */ function populateSasMolInfo(param){ var propDiv = document.createElement('div'); var propInfo = document.createElement('div'); var propCheckBox = document.createElement('input'); var propTitle = document.createTextNode(param.title + ': '); var propText = document.createTextNode(param.info); propDiv.style.textAlign = 'left'; propInfo.appendChild(propText); propInfo.style.display = 'none' propCheckBox.type = 'checkbox'; propCheckBox.id = 'propCheckBox'+sobjIndex; propDiv.appendChild(propCheckBox); propDiv.appendChild(propTitle); propDiv.appendChild(propInfo); sasmolInfoDiv.appendChild(propDiv); sobjContent.appendChild(sasmolInfoDiv); //toggles display on or off based on if the checkbox is ticked propCheckBox.addEventListener('click', function(e){ if(!propCheckBox.checked){ propInfo.style.display = 'none' } else{ propInfo.style.display = 'block'; } }); } /** * generic object passed as param to populateSasMolInfo * @namespace * @prop {string} title title of sasmol field * @prop {string} info literal text of what to display (account for big files) */ var sasmolInfoObj = { title: '', info: '' }; var segnameObj = Object.create(sasmolInfoObj); segnameObj.title = 'SEGNAME'; //display range (first - last) segnameObj.info = object.getSegname()[0] + ' ... ' + object.getSegname()[object.getSegname().length - 1]; var betaObj = Object.create(sasmolInfoObj); betaObj.title = 'BETA'; //display range (first - last) betaObj.info = object.getBeta()[0] + ' ... ' + object.getBeta()[object.getBeta().length - 1]; populateSasMolInfo(segnameObj); populateSasMolInfo(betaObj); //push to arrays widgetContainerArr[i] = widgetContainer; seqContainerArr[i] = sequenceContainer; seqDivArr[i] = sequenceDiv; locatorDivArr[i] = locatorDiv; locatorBoxArr[i] = locatorBox; zoomDivArr[i] = zoomDiv; // seqSelDivArr[i] = selectDisplay; seqSelRangeDivArr[i] = selectDisplayRange; } //POPULATE PDB MEMORY BOX //output is just an array of strings that get converted to text displayed in HTML var output = []; //FUTURE DEVELOPMENT //ex: chain A is hardcoded (future goal: make modular after implementing read MODEL/chain) output.push('&lt;li&gt;', 'chain A','&lt;ul&gt;'); //uncomment below to loop through entire numAtoms (bad idea for huge pdb files) // for(var i = 0; i&lt;numAtomsArr[sobjIndex]; i++){ // //iterate through atoms and display in bullets // output.push('&lt;li&gt;', object.getAtom()[i], '&lt;/li&gt;'); // } // only print first and last output.push('&lt;li&gt;', object.getAtom()[0], '&lt;/li&gt;'); output.push('&lt;li&gt;', '...', '&lt;/li&gt;'); output.push('&lt;li&gt;', object.getAtom()[numAtomsArr[sobjIndex] - 1], '&lt;/li&gt;'); //end of ul output.push('&lt;/ul&gt;','&lt;/li&gt;'); document.getElementById('pdb_memory').innerHTML = '&lt;ul&gt;' + output.join('') + '&lt;/ul&gt;'; //(Debugging purposes) loadBool = true; } //DOCUMENT EVENT LISTENERS //make keypress event general (only open if there exists a value to be_zoomed in on) document.addEventListener('keydown',function(e){ //only zoom on active elements (sequenceDiv can be focused by right-clicking) var activeElt = document.activeElement; if(e.shiftKey &amp;&amp; seqDivFlag &amp;&amp; (activeElt.className == 'sequenceDiv')){ //switch on flag zoomPress = true; //extract id var reg = /(\\d)/; var sobjIndex = reg.exec(activeElt.id)[1]; //console.log(sobjIndex); zoomDivArr[sobjIndex].style.display = 'block'; if((parseInt(locatorBoxArr[sobjIndex].innerText) &lt; seqObjArr[sobjIndex].length)){ //grab index displayed in locatorDiv and populate zoom div var index = parseInt(locatorBoxArr[sobjIndex].innerText); populateZoomDiv(index, sobjIndex); } currentZoomedWidget = sobjIndex; } }); //Keyup event doesn't apply to a specific key so use a flag to check if zoom was held before document.addEventListener('keyup',function(e){ if(zoomPress){ //remove all HTML for marking zoom ranges for(var i = 0; i&lt; document.querySelectorAll('.zoomed-lefthook').length;i++){ document.querySelectorAll('.zoomed-lefthook')[i].classList.remove('zoomed-lefthook'); document.querySelectorAll('.zoomed-righthook')[i].classList.remove('zoomed-righthook'); } zoomDivArr[currentZoomedWidget].style.display = 'none'; //switch off flag zoomPress = false; } }); /** * initialize sequence objects inside divs (main HTML handler) * @name initialize * @func * @param {string} action denotes action to be taken (FUTURE DEVELOPMENT) - can pass 'start', possibly 'reload' in the future for responsiveness * @param {SasMol.SasMol} object sasmol objects * @param {number} sobjIndex sobj Index */ function initialize(action, object, sobjIndex){ var seqDiv = seqDivArr[sobjIndex]; //initialize seqobjarray[sobjIndex] to empty array (fill in later) seqObjArr[sobjIndex] = []; var num = numAtomsArr[sobjIndex]; // Logic to make divs responsive (FOR FUTURE DEVELOPMENT - would have to re-initialize everything) if(action=='reload'){ $('.sequenceDiv '+ sobjIndex).find('.res').remove(); $('.sequenceDiv '+ sobjIndex).find('.dividers').remove(); } //update calculation (4 is for the pixel border - find in widgetStyle.css) var seqDivWidth = seqDivArr[sobjIndex].offsetWidth-4; //initialize span elements for(var i=0;i&lt;num;i++){ var newSpan = document.createElement('span'); newSpan.className = 'res'; newSpan.style.width = (seqDivWidth/num) + 'px'; newSpan.id = '_' + Math.random().toString(36).substr(2, 9); /** * MODULAR sequence object (as opposed to original method of embedding sasmol information inside DOM id's and using regex's to slice everywhere) * @namespace * @prop {SasMol} sasAtom corresponding sasmol object * @prop {String} dom_id corresponding DOM id * @prop {boolean} zoomed boolean flag for detecting if elt is being zoomed on (currently UNUSED) * @prop {boolean} selected boolean flag for detecting if elt is selected (currently UNUSED) * @prop {number} pdbIndex corresponding sobjIndex * @prop {String} zoomText text to display when elt is being zoomed in on (currently atom name) * @prop {number} seqObjArrIndex index of seqObj inside parent seqObjArr */ var seqObj = { sasAtom: object, dom_id : newSpan.id, zoomed : false, selected : false, pdbIndex : sobjIndex, zoomText : object.getName()[i] + '\\n' + object.getAtom()[i], seqObjArrIndex: i }; //add seqobj to global seqobj array seqObjArr[sobjIndex][i] = seqObj; seqDiv.appendChild(newSpan); //insert dividers var newDivider = document.createElement('div'); newDivider.className = 'divider'; //logic for limits on dividers if(num &lt;= 20 &amp;&amp; i&lt;num){ createDivider(); } else if(i%10==0 &amp;&amp; num &lt;= 200 &amp;&amp; i&lt;num){ createDivider(); } else if(i%100==0 &amp;&amp; num &lt;=2000 &amp;&amp; i&lt;num){ createDivider(); } /** * creates dividers * @name createDivider * @func */ function createDivider(){ newDivider.style.left = (seqDivWidth/num)*i + 'px'; newDivider.style.fontSize = '12px'; var textNode = document.createTextNode(i+1); newDivider.appendChild(textNode); seqDiv.appendChild(newDivider); } } //update elt width after new calculations eltWidth = document.querySelectorAll('.res')[0].getBoundingClientRect().width; seqDivWidthArr[sobjIndex] = seqDivWidth; eltWidthArr[sobjIndex] = eltWidth; //DEMO console.log(seqObjArr); //instantiate dragselectors - refer to DRAGSELECTJS API for what these fields mean //https://thibaultjanbeyer.github.io/DragSelect/ var ds = new DragSelect({ selectables: document.getElementsByClassName('res'), area: seqDiv, multiSelectKeys: ['ctrlKey'], onDragMove: function(e){ var selection = dsArr[sobjIndex].getSelection(); //only do computations if there selection array isn't empty if(selection.length&gt;0){ var lastEltID = selection[selection.length-1].id; //console.log(&quot;lastELt: &quot;+lastElt); var obj = getObjectByValue(seqObjArr[sobjIndex], lastEltID); updateCurrSelection('endIndex', obj, sobjIndex); } }, onDragStart: function(e){ var selection = dsArr[sobjIndex].getSelection(); //only do computations if there selection array isn't empty if(selection.length&gt;0){ var lastEltID = selection[selection.length-1].id; //console.log(&quot;lastELt: &quot;+lastElt); var obj = getObjectByValue(seqObjArr[sobjIndex], lastEltID); updateCurrSelection('startIndex', obj, sobjIndex); } }, callback: function(){ var selection = dsArr[sobjIndex].getSelection(); if(selection.length==0){ updateCurrSelection('startIndex', {atomNum: &quot;&quot;}, sobjIndex); updateCurrSelection('endIndex',{atomNum: &quot;&quot;}, sobjIndex); } calibrateDisp(sobjIndex); updateSelDisplay(sobjIndex); }, selector: document.getElementsByClassName('customSelector')[sobjIndex], onElementSelect: function(item){ mirror(item,'select', sobjIndex); }, onElementUnselect: function(item){ mirror(item,&quot;unselect&quot;, sobjIndex); } }); //instantiate new dragselect within zoombox var zoomds = new DragSelect({ multiSelectKeys: ['ctrlKey'], area:zoomDivArr[sobjIndex], onDragMove: function(e){ var selection = zoomdsArr[sobjIndex].getSelection(); //only do computations if there selection array isn't empty if(selection.length&gt;0){ var lastEltID = selection[selection.length-1].id; var obj = getObjectByValue(seqObjArr[sobjIndex], lastEltID); updateCurrSelection('endIndex', obj, sobjIndex); } }, onDragStart: function(e){ var selection = zoomdsArr[sobjIndex].getSelection(); //only do computations if there selection array isn't empty if(selection.length&gt;0){ var lastEltID = selection[selection.length-1].id; //console.log(&quot;lastELt: &quot;+lastElt); var obj = getObjectByValue(seqObjArr[sobjIndex], lastEltID); updateCurrSelection('startIndex', obj, sobjIndex); } }, //ensure that select/unselect actions are mirrored in both primary seq div and zoom div onElementSelect: function(item){ mirror(item,'select', sobjIndex); }, onElementUnselect: function(item){ mirror(item,&quot;unselect&quot;, sobjIndex); }, callback: function(){ var selection = dsArr[sobjIndex].getSelection(); //DEMO //console.log(selection); if(selection.length==0){ updateCurrSelection('startIndex',null, sobjIndex); updateCurrSelection('endIndex',null, sobjIndex); } calibrateDisp(sobjIndex); updateSelDisplay(sobjIndex); } }); //add to arrays dsArr[sobjIndex] = ds; zoomdsArr[sobjIndex] = zoomds; //css hack (unnecessary? ) widgetContainerArr[sobjIndex].style.position = 'absolute'; } /************************************************************************** _ _ ___ __ ___ ___ ___ ___ _ _ _ _ __ ____ __ __ _ _ ___ ( )( )( _)( ) ( ,\\( _)( ,) ( _)( )( )( \\( )/ _)(_ _)( )/ \\( \\( )/ __) )__( ) _) )(__ ) _/ ) _) ) \\ ) _) )()( ) (( (_ )( )(( () )) ( \\__ \\ (_)(_)(___)(____)(_) (___)(_)\\_) (_) \\__/ (_)\\_)\\__) (__) (__)\\__/(_)\\_)(___/ *************************************************************************/ /** * helper function for mirroring selection/unselection between primary sequence div and zoom div * @name mirror * @func * @param {HTML_NODE} item HTML node to be mirrored (template) * @param {String} type type of action - select or unselect * @param {Number} sobjIndex sobj Index */ function mirror(item,type, sobjIndex){ var zoomSel = zoomdsArr[sobjIndex].getSelection(); var mainSel = dsArr[sobjIndex].getSelection(); //SUBJECT TO CHANGE (depends on ID) var regex = /_[^_]*/; equivID = regex.exec(item.id)[0]; //DEMO //console.log(equivID); if(type == &quot;unselect&quot;){ dsArr[sobjIndex].removeSelection(document.getElementById(equivID)); if(document.getElementsByClassName('zoomDiv')[sobjIndex].childNodes.length &gt; 1){ zoomdsArr[sobjIndex].removeSelection(document.getElementById(equivID+'_zoomed')); } } else if(type ==&quot;select&quot;){ dsArr[sobjIndex].addSelection(document.getElementById(equivID)); if(document.getElementsByClassName('zoomDiv')[sobjIndex].childNodes.length &gt; 1){ zoomdsArr[sobjIndex].addSelection(document.getElementById(equivID+'_zoomed')); } } } /** * Purpose: Adjust innerText of Sequence Feedback box to show current Selection * @name updateCurrSelection * @func * @param {String} spanClass name of span class ('startIndex' or 'endIndex') * @param {Object} object object defined in initialize() function * @param {Number} sobjIndex sobj Index */ function updateCurrSelection(spanClass, object, sobjIndex){ var str = &quot;&quot;; if(object != null){ str = object.sasAtom.getAtom()[object.seqObjArrIndex].toString(); } document.getElementsByClassName(spanClass)[sobjIndex].innerText = str; } /** * PURPOSE: Adjust HTML of the Selection range Div in the feedback Box (displays subarrays of selections) * @name updateSelDisplay * @func * @param {Number} sobjIndex sobj Index */ function updateSelDisplay(sobjIndex){ //add display for SELECTION (split into contiguous arrays) var len = arrDisp.length; //clear children first while (seqSelRangeDivArr[sobjIndex].firstChild) { seqSelRangeDivArr[sobjIndex].removeChild(seqSelRangeDivArr[sobjIndex].firstChild); } if(len&gt;0){ for(var i=0;i&lt;len;i++){ //initialize 'from' text var selspan = document.createElement('span'); var subArray = arrDisp[i]; var text = (subArray[0]).toString(); //if subArray has more than one element, initialize colon part and 'to' part if(subArray.length&gt;1){ //additional part (intermediate and end) var mid = ' - '; var toText = (subArray[subArray.length-1]).toString(); text+=mid; text+=toText; } var textNode = document.createTextNode(text); selspan.appendChild(textNode); selspan.classList.add('subArray'); seqSelRangeDivArr[sobjIndex].appendChild(selspan); } } } /** * PURPOSE: helper method for clearing selection (making selection array zero, removing DOM children elements) * @name clearAllSelection * @func * @param {Number} sobjIndex sobj Index */ function clearAllSelection(sobjIndex){ dsArr[sobjIndex].clearSelection(); $('.ds-selected').remove(); arrDisp.length=0; updateSelDisplay(sobjIndex); updateCurrSelection('startIndex',null,sobjIndex); updateCurrSelection('endIndex',null,sobjIndex); } /** * PURPOSE: split selection array into consecutive subArrays; called when selection is made * @name calibrateDisp * @func * @param {Number} sobjIndex sobj Index */ function calibrateDisp(sobjIndex){ //console.log(sobjIndex); objArrKeyIndex = -1; //reset array arrDisp=[]; var selection = dsArr[sobjIndex].getSelection(); var len = selection.length; var currKey; var prevKey; var arrSorted = []; var subArray = []; var arrDispIndex = 0; //1. sort Array for(var i=0; i&lt;len;i++){ currKey = getObjectByValue(seqObjArr[sobjIndex], dsArr[sobjIndex].getSelection()[i].id).seqObjArrIndex; //keys are zero-indexed so add 1 to make compatible with atom numbering arrSorted.push(currKey + 1); } arrSorted.sort(function (a, b) { return a - b; }); //2. update array for(var i=0; i&lt;len;i++){ //for the first element only, initialize subArray if(i==0){ currKey = arrSorted[0]; prevKey = currKey; subArray.push(currKey); arrDisp.push(subArray); } //for all other elements, compute logic for currKey and prevKey (inapplicable to first elt) else{ currKey = arrSorted[i]; prevKey = arrSorted[i-1]; //check if contiguous if(prevKey == (currKey - 1)){ arrDisp[arrDispIndex].push(currKey); } else{ //if not contiguous, create new subArray subArray = []; subArray.push(currKey); arrDisp.push(subArray); arrDispIndex++; } } } //DEMO // console.log(arrDisp); } /** * Helper function for retrieving a key by its value * @name getKeyByValue * @func * @param {Object} arr There is no official JavaScript type for an Array so it is technically an Object * @param {String|Number|Boolean} value value to search with * @return {String|Number|Boolean} matched key to value */ function getKeyByValue(arr, value) { for(var i=0, iLen = arr.length; i&lt;iLen;i++){ for (key in arr[i]){ if(arr[i][key] == value){return key;} } } } /** * Helper function for retrieving an object by its value (key:value), see structure of seqObj defined in Initialize() to understand why this may be useful * @name getObjectByValue * @func * @param {Object} arr There is no official JavaScript type for an Array so it is technically an Object * @param {String|Number|Boolean} value value to search with * @return {Object} matched object */ function getObjectByValue(arr, value) { for(var i=0, iLen = arr.length; i&lt;iLen;i++){ for (key in arr[i]){ if(arr[i][key] == value){return arr[i];} } } } /** * Function for toggling on the displayLocator box * @name displayLocator * @func * @param {String} loc string to fill locator box with * @param {Number} sobjIndex sobj Index */ function displayLocator(loc, sobjIndex){ locatorDivArr[sobjIndex].style.display='block'; locatorBoxArr[sobjIndex].innerText=loc; } /** * Function for geometrically computing (sequence) index based on position of mouse * @name getIndexByWidth * @func * @param {Number} x x coordinate of mouse * @param {Number} sobjIndex sobj Index * @return {Number} &quot;equivalent&quot; sequence index */ function getIndexByWidth(x, sobjIndex){ return Math.ceil(x/eltWidthArr[sobjIndex]); } /** * Fills zoomDiv with HTML elements; takes in value in locatorBox to display a range * @name populateZoomDiv * @func * @param {Number} index sequence index * @param {Number} sobjIndex sobj Index */ function populateZoomDiv(index, sobjIndex){ //clear children except selector box while(zoomDivArr[sobjIndex].children.length&gt;1){ zoomDivArr[sobjIndex].removeChild(zoomDivArr[sobjIndex].lastChild); } var zoomRangeLeft; var zoomRangeWidth; // MAKE MODULAR (values in parentheses can be variadic in the future) var lorange = index - (5) - 1; if(index &lt;= (5)){ lorange = 0; } var hirange = index + (5); if(hirange &gt; seqObjArr[sobjIndex].length){ hirange = seqObjArr[sobjIndex].length; } for(var i = lorange; i&lt;hirange;i++){ var obj = getObjectByValue(seqObjArr[sobjIndex],i); var atomName = obj.sasAtom.getName()[obj.seqObjArrIndex]; var atomNum = obj.sasAtom.getAtom()[obj.seqObjArrIndex]; var resZoom = document.createElement('span'); resZoom.className = 'res'; resZoom.innerText = obj.zoomText; var id = obj.dom_id; resZoom.id = id+'_zoomed'; resZoom.style.height = '30px'; resZoom.style.width = '30px'; resZoom.style.fontSize = '14px'; resZoom.style.margin = '5px'; resZoom.style.border = '1px solid black'; zoomDivArr[sobjIndex].appendChild(resZoom); zoomdsArr[sobjIndex].addSelectables(resZoom); //mirror in zoomDiv because these new spans are called after selection in primary seq div var mirrorItem = document.getElementById(id); //check if selected if(mirrorItem.className.includes('ds-selected')){ mirror(mirrorItem,&quot;select&quot;, sobjIndex); } //HTML stuff for marking edges of a zoom range if(i==lorange){ mirrorItem.classList.add('zoomed-lefthook'); zoomRangeLeft = mirrorItem.offsetLeft; } else if(i==hirange-1){ mirrorItem.classList.add('zoomed-righthook'); } //FUTURE DEVELOPMENT - add some CSS for marking intermediate zoomed - elts? // else{ // mirrorItem.classList.add('zoomed-middle'); // } } } /** * Helper function to get an element's exact position (if nested in container divs) * CREDIT: https://www.kirupa.com/html5/get_element_position_using_javascript.htm * @name getPosition * @func * @param {HTML_NODE} el HTML node of interest * @return {Object} object with x and y coordinates */ function getPosition(el) { var xPos = 0; var yPos = 0; while (el) { if (el.tagName == &quot;BODY&quot;) { // deal with browser quirks with body/window/document and page scroll var xScroll = el.scrollLeft || document.documentElement.scrollLeft; var yScroll = el.scrollTop || document.documentElement.scrollTop; xPos += (el.offsetLeft - xScroll + el.clientLeft); yPos += (el.offsetTop - yScroll + el.clientTop); } else { // for all other non-BODY elements xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft); yPos += (el.offsetTop - el.scrollTop + el.clientTop); } el = el.offsetParent; } return { x: xPos, y: yPos }; } } );//end of jQuery.ready() × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Global Members newBobj :module:JSSSE~bobj bobj object Type: module:JSSSE~bobj Source: widgetJS.js, line 43 testSobj :module:JSSSE~sobj sobj object Type: module:JSSSE~sobj Source: widgetJS.js, line 50 Methods readFile(file) use Promises to wait until async operation is finished (initialize + populate windows correctly) src: https://stackoverflow.com/questions/41906697/how-to-determine-that-all-the-files-have-been-read-and-resolve-a-promise/ Parameters: Name Type Description file File file object Source: widgetJS.js, line 63 readmultifiles(files) use promises to wait until async operation is finished, calls helper method readFile Parameters: Name Type Description files Array.&lt;File&gt; array of file objects (different than FileList object) Source: widgetJS.js, line 81 Returns: array of files read (in literal text) Type Array.&lt;string&gt; handleRead(e) main function triggered by event - calls multifiles to parse files Parameters: Name Type Description e event event object - use to extract files Source: widgetJS.js, line 130 populateWindows(sobjID, object) Populates windows attached to sobj's (all HTML necessary for sequence divs, feedback box, zoom div) Parameters: Name Type Description sobjID String [dom ID of sobj] object sasmol sasmol object Source: widgetJS.js, line 202 populateSasMolInfo(param) populates Sasmol info div - refer to object definition below to know what to pass as parameter also handles display toggling (via checkbox eventlistener) Parameters: Name Type Description param sasmolInfo sasmol info object (definied below) Source: widgetJS.js, line 384 initialize(action, object, sobjIndex) initialize sequence objects inside divs (main HTML handler) Parameters: Name Type Description action string denotes action to be taken (FUTURE DEVELOPMENT) - can pass 'start', possibly 'reload' in the future for responsiveness object SasMol.SasMol sasmol objects sobjIndex number sobj Index Source: widgetJS.js, line 527 createDivider() creates dividers Source: widgetJS.js, line 597 mirror(item, type, sobjIndex) helper function for mirroring selection/unselection between primary sequence div and zoom div Parameters: Name Type Description item HTML_NODE HTML node to be mirrored (template) type String type of action - select or unselect sobjIndex Number sobj Index Source: widgetJS.js, line 735 updateCurrSelection(spanClass, object, sobjIndex) Purpose: Adjust innerText of Sequence Feedback box to show current Selection Parameters: Name Type Description spanClass String name of span class ('startIndex' or 'endIndex') object Object object defined in initialize() function sobjIndex Number sobj Index Source: widgetJS.js, line 766 updateSelDisplay(sobjIndex) PURPOSE: Adjust HTML of the Selection range Div in the feedback Box (displays subarrays of selections) Parameters: Name Type Description sobjIndex Number sobj Index Source: widgetJS.js, line 782 clearAllSelection(sobjIndex) PURPOSE: helper method for clearing selection (making selection array zero, removing DOM children elements) Parameters: Name Type Description sobjIndex Number sobj Index Source: widgetJS.js, line 822 calibrateDisp(sobjIndex) PURPOSE: split selection array into consecutive subArrays; called when selection is made Parameters: Name Type Description sobjIndex Number sobj Index Source: widgetJS.js, line 837 getKeyByValue(arr, value) Helper function for retrieving a key by its value Parameters: Name Type Description arr Object There is no official JavaScript type for an Array so it is technically an Object value String | Number | Boolean value to search with Source: widgetJS.js, line 894 Returns: matched key to value Type String | Number | Boolean getObjectByValue(arr, value) Helper function for retrieving an object by its value (key:value), see structure of seqObj defined in Initialize() to understand why this may be useful Parameters: Name Type Description arr Object There is no official JavaScript type for an Array so it is technically an Object value String | Number | Boolean value to search with Source: widgetJS.js, line 910 Returns: matched object Type Object displayLocator(loc, sobjIndex) Function for toggling on the displayLocator box Parameters: Name Type Description loc String string to fill locator box with sobjIndex Number sobj Index Source: widgetJS.js, line 927 getIndexByWidth(x, sobjIndex) Function for geometrically computing (sequence) index based on position of mouse Parameters: Name Type Description x Number x coordinate of mouse sobjIndex Number sobj Index Source: widgetJS.js, line 938 Returns: &quot;equivalent&quot; sequence index Type Number populateZoomDiv(index, sobjIndex) Fills zoomDiv with HTML elements; takes in value in locatorBox to display a range Parameters: Name Type Description index Number sequence index sobjIndex Number sobj Index Source: widgetJS.js, line 951 getPosition(el) Helper function to get an element's exact position (if nested in container divs) CREDIT: https://www.kirupa.com/html5/get_element_position_using_javascript.htm Parameters: Name Type Description el HTML_NODE HTML node of interest Source: widgetJS.js, line 1017 Returns: object with x and y coordinates Type Object × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Modules Namespaces SasMol bobj sobj jssse sasmolInfoObj seqObj × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespaces Namespaces SasMol bobj sobj jssse sasmolInfoObj seqObj × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition JSSSE HomeJavaScript Sequence Structure Editor AbstractJavaScript Sequence Structure Editor (JSSSE) has been developed to edit details obtained in data files used by researchers to improve the building of initial structures and guide user input so that the information generated is compatible with modern molecular simulation programs. SASSIE-web is a scientific gateway built using the GenApp technology (https://genapp.rocks/) that enables researchers to build structures, perform Monte Carlo and molecular dynamics simulations, calculate neutron and x-ray small-angle scattering and reflectivity data on a wide variety of soft-matter systems (https://sassie-web.chem.utk.edu/sassie2/). We have developed new user input capabilities in Javascript and HTML5 to describe and edit molecular systems visually and intuitively while still interacting with the underlying physics. These user inputs will dramatically and fundamentally improve the user experience to broaden the number of potential users of our gateway. The software will be available to all applications developed using the GenApp technology and as a stand-alone component for other scientific gateways. We believe that other scientific gateway developers with molecular simulation-based applications will be able to use JSSSE to enhance their software and improve the impact of their user communities. We thank the Science Gateways Community Institute’s Summer Intern program for supporting Nayman Leung. We thank Susan Krueger (NIST), Cheol Jeong (UTK/NIST), and David Wright (UCL) for their feedback and design assistance. Emre Brookes is supported by NSF grant OAC-1740097 (to Emre Brookes) and NIH grant GM120600 (to Borries Demeler). CODE REVIEW:I couldn't find a way to attach a MD file in addition to the one used to generate the index.html so I've included the Code Review section here (can relocate in the future). I highly recommend going through this guide/rant(?!) thoroughly but a TL;DR section is also available. Minimum understanding: HTML structure of widget, DragSelectJS API, widgetJS API (helper methods all in Global namespace tab) legend: stuff marked in italics are side comments bold italics are pretty important comments Overview: Repository Directory Structure Comprehensive Code Review File 1 - SasMol File 2 - JSSSE File 3 - WidgetJS Known Bugs + possible ideas for solutions Afterthoughts + Directions Forward REPOSITORY DIRECTORY STRUCTURETree structure generated by Linux tree using command: tree -I 'bower_components|node_modules|fonts|styles' &gt; tree.txt-I flag ignores huge folders like bower_components, node_modules, and fonts + scripts files outputted by JSDOC/bootstrap (using the COLLAPSIBLE CONTENT:) hack works for normal Github markdown but not for JSDoc so unfortunately this fat tree below will have to be here...or someone can remove it entirely..) . ├── docs │ ├── -_anonymous_-initialize-seqObj.html │ ├── -_anonymous_-populateWindows-sasmolInfoObj.html │ ├── bobj.html │ ├── global.html │ ├── img │ │ ├── glyphicons-halflings.png │ │ └── glyphicons-halflings-white.png │ ├── index.html │ ├── jssse.html │ ├── jssse.js.html │ ├── module-JSSSE-bobj.html │ ├── module-JSSSE.html │ ├── module-JSSSE-jssse.html │ ├── module-JSSSE-sobj.html │ ├── module-SasMol.html │ ├── module-SasMol-SasMol.html │ ├── modules.list.html │ ├── namespaces.list.html │ ├── quicksearch.html │ ├── SASMOL JS_sasmol.js.html │ ├── scripts │ │ ├── docstrap.lib.js │ │ ├── fulltext-search.js │ │ ├── fulltext-search-ui.js │ │ ├── linenumber.js │ │ ├── lunr.min.js │ │ ├── prettify │ │ │ ├── Apache-License-2.0.txt │ │ │ ├── jquery.min.js │ │ │ ├── lang-css.js │ │ │ └── prettify.js │ │ ├── sunlight.js │ │ └── toc.js │ ├── sobj.html │ └── widgetJS.js.html ├── images │ ├── bug1_IncorrectSplitSelection.png │ └── joseph_notes1.jpg ├── JS Widget Basics │ ├── bundle.js │ ├── conf.json │ ├── docIndex.md │ ├── Drafts&amp;Subprojects │ │ ├── arrDispArrTest.js │ │ ├── bundle.js │ │ ├── index.html │ │ ├── javascript.js │ │ ├── oldCSS.css │ │ ├── oldDragSelect.js │ │ ├── oldIndex.html │ │ ├── Sequence Object Redesign │ │ │ ├── bundle │ │ │ ├── bundle.js │ │ │ ├── index.html │ │ │ ├── javascript.js │ │ │ └── style.css │ │ ├── Sequence Selector Draft 1 │ │ │ ├── index_draft1.html │ │ │ ├── javascript_draft1.js │ │ │ └── style_draft1.css │ │ ├── style.css │ │ └── workingDemo.js │ ├── DragSelect.js │ ├── High Level Tests │ │ ├── canvasPlanCSS.css │ │ ├── canvasPlan.html │ │ ├── canvasPlanJS.js │ │ ├── conf.json │ │ ├── module1.js │ │ ├── testDrag2.js │ │ ├── testDragCSS.css │ │ ├── testDrag.html │ │ ├── testDragJS.js │ │ ├── testFileMultiRead.js │ │ ├── testFileReadIndex.html │ │ ├── testjsdoc.js │ │ └── testOut │ │ ├── global.html │ │ ├── index.html │ │ ├── module1.js.html │ │ ├── module-A.html │ │ ├── module-Obj.html │ │ ├── module-Person.html │ │ ├── module-Person-Person.html │ │ ├── module-testJSDOC.html │ │ ├── scripts │ │ │ ├── linenumber.js │ │ │ └── prettify │ │ │ ├── Apache-License-2.0.txt │ │ │ ├── lang-css.js │ │ │ └── prettify.js │ │ └── testjsdoc.js.html │ ├── jspdb.js │ ├── jssse.js │ ├── package.json │ ├── package-lock.json │ ├── readFiles.js │ ├── SASMOL JS │ │ ├── 1AA-NoEND.pdb │ │ ├── 1bdg.pdb │ │ ├── 4ibc.pdb │ │ ├── 6djx.pdb │ │ ├── drafts │ │ │ ├── bundle.js │ │ │ ├── index.html │ │ │ ├── sasioDraft2.js │ │ │ ├── sasioDraft.js │ │ │ ├── sasmolDraft.js │ │ │ └── scripts │ │ │ ├── main.js │ │ │ ├── objects.js │ │ │ ├── require.js │ │ │ └── testRequire1.js │ │ ├── numjs │ │ ├── numjstest.js │ │ ├── pdbDebug.pdb │ │ ├── res.pdb │ │ ├── sasIndex.html │ │ ├── sasio.js │ │ ├── sasmol-bundle.js │ │ ├── sasmol.js │ │ ├── sasmol.py │ │ ├── sasmol.pyc │ │ ├── sprintfTest.js │ │ ├── system.py │ │ └── test.py │ ├── server.js │ ├── test.txt │ ├── widget.html │ ├── widgetJS.js │ └── widgetStyle.css ├── README.md ├── SASMOL JS │ ├── sasIndex.html │ ├── sasio.js │ ├── sasmol-bundle.js │ └── sasmol.js ├── testing │ └── events.js └── tree.txt 18 directories, 123 files/Directories and Files in Root (final design path marked in bold, excludes files needed for JSDoc): /Doc - holds necessary HTML/js files for the documentation website generated by JSDoc/Bootstrap /Images - pictures used in poster, pictures used in this code review, misc. pics /JS Widget Basics - contains meat of code Bower_components - jQuery files Drafts&amp;Subprojects - folder containing drafts of the main HTML/JS files that I worked with before copying over to widgetJS + widget.html. (lazy version control basically) For those who are curious: /Sequence Selector Draft 1 - has initial design of dragselect before discovering an established version online. /Sequence Object Redesign - contains drafts working with the seqObj dilemma I dealt with (vs regex embedded dom id's). High Level Tests - HTML/JS for initial canvas design, working with CSS Grid design, etc. Also contains unit tests for corresponding dragSelect, multiple file read before implementing into 'final' design Test Drag files - unit tests to ensure that selection in one box gets 'mirrored' in the other (essential for zoomdiv and main sequence div) /testOut - output of running JSDoc on some test JS files to make sure modules were being correctly documented in the final HTML output. readFile.js - initial testing for file reading server.js - file for learning about nodeJS server setup Node_modules - nodejs modules (For the final design, it may be good to consider moving used raw NodeJS modules into the main directory. However, this may be difficult if a module uses other modules (numjs maybe). In this case, it is probably best to use 'browserify' to automatically bundle everything) bundle.js - 'browserified' widgetJS.js (explanation for browserify in comprehensive code review) conf.json - configuration file for JSDoc docIndex.md - markdown file for main documentation page generated by JSDoc DragSelect.js - DragSelectJS module copied from Node_modules jspdb.js - old draft of JSSSE definition (before being renamed) jssse.js - definition for JSSSE, bobj, sobj namespaces + related methods widget.html - HTML file for widget widgetJS.js - JS file for widget, works with HTML generation and widget-related events widgetCSS.css - CSS file for styling the HTML /SASMOL JS - contains SasMol, Sasio (DEPRECATED), and SasIndex (used for debugging outputs of sasmol/sasio) (For reasons explained later, SasMol is the only important file in this directory - it should be relocated to the main directory with all of the widget definitions for optimization purposes to avoid confusion with organization if things somehow get moved around) /Testing - Prof. Brookes's testing files with events + undo/redo README.md - markdown page for github repo - should probably be updated tree.txt - output tree file COMPREHENSIVE CODE REVIEWBackground: SasMol is a class first delineated by Dr. Curtis in Python. Its junior version in JS here only parses ATOM records in PDB's. Functionality should be extended to accommodate different file formats and more PDB records. As of now, SasMol (js) contains both the class definition AND the methods for parsing the PDB in the same file (as opposed to separate sasmol and sasio in python). This is why SasMol is the only important file in the 'SASMOL JS' folder. Adding support for more records should simply be a matter of emulating the regex parsing method. Different file formats require more expertise JSSSE contains definitions and methods for the JSSSE, bobj, sobj namespaces. They are based off of API v0.2 on the Github Repo. WidgetJS contains all of the HTML generation and widget-related events. The 3 main JS files listed above should be well documented with JSDoc/Bootstrap. JSDoc API is also easy to understand. Shortcut for Github's Atom editor for generating JSDoc headers is to type '/**' + TAB. SasMol - I've tried my best to emulate the style in the Python counterpart. As more PDB Records are accounted for, I assume the currently undefined data properties (index, original_index, moltype, conect, residue_flag, original_resid, header) will be fixed up or removed. Currently, readPDB and writePDB only deal with string inputs as suggested by Prof. Brookes. In older drafts, I experimented with using NodeJS fs and a npm module (readline) for reading a file line by line but since this will most likely be done in the browser, string I/O is the way to go. The vsprintf module is pretty neat to use (formats strings using identifiers, etc) so I was able to implement Dr. Curtis's specifiers with success. It's probably useful for printing other records. The only trouble I had with following the Python SasMol part was the coor part. I could easily populate the numjs coor nd array but I couldn't figure out how to use analogous python methods for slicing it to retrieve the contents in a meaningful way (I believe numjs only allows elt-by-elt slicing, not row). So I resorted to using a simple object definition like so: coor: {x: blah, y: blah, z: blah} since populating it and accessing it is trivial (I don't know about the overhead, efficiency, etc). JSSSE - the definitions and related methods are pretty well-defined in the API. Sidenotes will only be mentioned here. Is JSSSE supposed to have properties? I've left them empty for now. I've added a 'sobjIndex' property for keeping track of sobj generation and position of most recently added sobj in the sobjs array. (ex: at start, the index is 0. Everytime a new sobj is created, increment the index so the next sobj can be assigned to the correct index in the array (as opposed to using array.push()). Likewise, everytime sobj is removed, decrement the index so you are always keeping track of the position). There may be better ways of doing this. I've added a 'sasmol' property for sObj because I felt it was necessary to keep track of PDB information while conveniently using a namespace we had already defined. It may be good to move all PDB reading event related code into this file. Currently, the WidgetJS.js file handles when the reading when the 'Read PDB(s)' button is pressed (creates SasMol object, calls SasMol.readPDB to populate the SasMol, and assigns populated SasMol to sobj.sasmol field). I assume fields like loadOptions and various other 'options' objects will be better defined as more code is written WidgetJS - the whole file can be generally divided into: JSSSE + SasMol definitions in Main, Developer code, and Helper Methods. It is paramount to understand how the widget HTML is structured before looking at how the elements are brought into existence + related events for handling what/when boxes appear, etc in this file. Editing existing stuff in the HTML requires careful consideration of what also gets changed in the JS file. Also review DragSelectJS API to save time code-reading (google search will suffice) Disclaimer: There are many ways for simplifying JS using the jQuery $ operator. Immediate examples that come to mind are DOM traversals ex: $('.class') instead of document.getElementsByClassName('class') and other methods like $('.class').remove() vs accessing parent node and looping through the HTML child node collection and calling removeChild(). JSSSE + SasMol definitions in Main: handles 'read PDB(s)' button click event. Triggers reading functions which then populate the sasmol + sobj.sasmol field contains examples for how to create sobj objects, sasmol objects, bobj objects in main. Developer code I've thought over how to handle multiple pdb + sobj loading for a while and one way to go about it is to keep track of a global sobjIndex variable that you use to access DOM elements unique to each sobj. Then, while you are dynamically creating HTML elements, you can push them into arrays and access them using the global sobjIndex variable (or alternatively, using the document.getElementsByClassName('class')[sobjIndex] way since keeping track of all of the arrays becomes unwieldy especially with many nested HTML elements). Prof. Brookes introduced an idea about managing things at the top level bobj element but this aspect clearly requires more thought populateWindows( ... ) gets called to generate the skeleton of the widget - this does not include the residues and related selection functionalities. This method also populates the PDB memory box and PDB contents inside the sobj window (toggle-able properties like SEGNAME, beta, etc) More fine-tuning is needed for populating the pdb memory box. This most likely requires support for more PDB records (MODELS?) to populate the CHAINS HTML unordered list element (ul). Furthermore, making the list elements (li) collapsible would be pretty nice but also keep in mind the size of the pdb. Consider emulating how large elements are displayed in Chrome Developer Tools - it gets (dynamically?) subdivided into segments. ex: 0-99, 100-199, etc. This can be seen after uncommenting a console.log(seqObjArr) statement. the PDB contents inside the sobj window also need some fine-tuning as to what gets displayed. Selection only? First 10 and last 10? Just first and last? For now, I have it at first ... last, similar to how it is done in the PDB memory box. initialize( ... ) engenders functionality within the sequence div - allowing selection, events to track cursor hovering in real-time, zooming, etc. See how to define a seqObj in this section of the code. Its properties are modular (right now, zoomed and selected are unused because I was afraid of clobbering the already well-established selection logic). Properties like seqObjArrIndex should be pretty straightforward for understanding how to keep track of the elt in the grand scheme. However, there may be better ways of structuring this. SeqObj's and the DragSelect Objects are the main takeaways here - events associated with the DragSelect Objects call upon helper functions to do the 'magic'. createDividers() has some rudimentary logic, consider redesigning it for responsiveness, etc. I didn't research how to represent tickmarks conventionally, etc. The way it's done in the nice NCBI widget is to overlay a pre-made image of a canvas so they basically had other software generate that part instead of doing it on the fly. Helper Methods all methods are pretty well documented in the API generated by JSDoc and contain comments on their own. Most take in sobjIndex as a parameter, so if the multiple sObj idea gets changed, then many of these helper functions may ahve to be rewritten to ensure that the right HTML elements get altered. using getObjectByValue is risky if two fields of seqObj may potentially have the same value. So it is unadvisable to use it with Booleans, and other numeric values. As of now, I use it on the only numeric field seqObjArrIndex. (previously, I included several SasMol fields into the seqObj, but making a linked SasMol field eliminates this issue). populateZoomDiv( ... ) does what the name implies. It should be made more modular if the user wants to increase the range allowed by the zoom. Consider adding a simple dropdown with values 5, 10, 15. getIndexByWidth( ... ) does some very rudimentary geometric calculations and populates the value inside the locatorBox. Consider fine-tuning this logic. For average-sized pdb's ranging in the thousands, there may not be any better way to track mouse hovering over the seqObj's than a simple geometric calculation. other methods such as updateSelDisplay, updateCurrSelection, calibrateDisp, clearAllSelection concern the sequence Feedback box. Key functionalities include splitting selection into coherent and contiguous subarrays. (ex: selection may look like this [1, 2, 3, 5, 6, 8, 10] which should logically look like this: [1-3, 5-8, 10]) KNOWN BUGS + POSSIBLE IDEAS FOR SOLUTIONS + TEMPORARY WORKAROUNDS selecting in the primary sequence div for average pdb's incorrectly splits selection array into a single element + array. Refer to picture Sol'n: ? While SHIFT is held to zoom, CTRL toggles zoom Div off. Possible Explanation: the eventlistener for keyup does not know which key has been lifted up Workaround: CTRL after MOUSEDOWN + selecting a range Solution: introduce boolean flags to differentiate between CTRL and SHIFT? Selecting in the Zoom Div while there is already a selection does not cancel the selection. Standard logic for the DragSelect module holds that a MOUSEDOWN + drag without holding a multi-select key (currently only CTRL) cancels all current selections (works in primary seq Div as opposed to Zoom Div). Possible Explanation: mirror( ... ) method is probably responsible for this. Marker doesn't accurately track hovered-over element (bug is not reproducible for smaller PDB's) Possible Explanation: the getIndexByWidth method may not use correct width (getBoundingClientRect? vs offsetLeft?) In Safari, user is able to select any text (especially dividers + zoomed text). First block in CSS for styling the .body{ } somehow does not account for this... Sol'n: ? Check if browser supported? More? document here... _Code needs to be written for dynamically creating the HTML parts of the Canvas and making sure it follows the CSS grid property. Index SASMOL JS/sasmol.js Class Definition and basic I/O for reading/writing PDB files Source: SASMOL JS/sasmol.js, line 2 Requires module:NPM:numjs module:NPM:sprintf-js Index jssse.js Class Definition of JSSSE, bobj, and sobj Source: jssse.js, line 1 Index widgetJS.js Manages html display of widget and corresponding functionalities Source: widgetJS.js, line 3 Requires module:JSSSE module:SasMol × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:39 pm using the DocStrap template. "},"module-SasMol.html":{"id":"module-SasMol.html","title":"Module: SasMol","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Module: SasMol Source: SASMOL JS/sasmol.js, line 8 Namespaces SasMol × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"module-SasMol-SasMol.html":{"id":"module-SasMol-SasMol.html","title":"Namespace: SasMol","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: SasMol SasMol~ SasMol SasMol Class definition Properties: Name Type Description data Object holder of all relevant PDB data Properties Name Type Description atom Array.&lt;Number&gt; array of atom serial numbers index Array.&lt;Number&gt; (UNDEFINED) original_index Array.&lt;Number&gt; (UNDEFINED) name Array.&lt;String&gt; atom name loc Array.&lt;String&gt; loc resname Array.&lt;String&gt; Residue name chain Array.&lt;String&gt; Chain id resid Array.&lt;Number&gt; residue sequence number rescode Array.&lt;String&gt; iCode coor Object numjs array coorObj Object object for storing coor xyz easier (than numjs) occupancy Array.&lt;Number&gt; occupancy beta Array.&lt;Number&gt; temp. factor segname Array.&lt;String&gt; segment name element Array.&lt;String&gt; element name charge Array.&lt;String&gt; charge moltype Array.&lt;String&gt; (UNDEFINED) conect Object (UNDEFINED) residue_flag Array.&lt;String&gt; (UNDEFINED) original_resid Array.&lt;String&gt; (UNDEFINED) header Array.&lt;String&gt; (UNDEFINED) Source: SASMOL JS/sasmol.js, line 45 Methods &lt;static&gt; atom(atom) atom setter Parameters: Name Type Description atom Array.&lt;Number&gt; atom array to set Source: SASMOL JS/sasmol.js, line 82 &lt;static&gt; getAtom() atom getter Source: SASMOL JS/sasmol.js, line 89 Returns: atom array to get Type Array.&lt;Number&gt; &lt;static&gt; index(index) index setter Parameters: Name Type Description index Array.&lt;Number&gt; index array to set Source: SASMOL JS/sasmol.js, line 96 &lt;static&gt; getIndex() index getter Source: SASMOL JS/sasmol.js, line 103 Returns: index array to get Type Array.&lt;Number&gt; &lt;static&gt; origIndex(index) origIndex setter Parameters: Name Type Description index Array.&lt;Number&gt; origIndex array to set Source: SASMOL JS/sasmol.js, line 110 &lt;static&gt; getOrigIndex() origIndex getter Source: SASMOL JS/sasmol.js, line 117 Returns: origIndex array to get Type Array.&lt;Number&gt; &lt;static&gt; name(name) name setter Parameters: Name Type Description name Array.&lt;String&gt; name array to set Source: SASMOL JS/sasmol.js, line 124 &lt;static&gt; getName() name getter Source: SASMOL JS/sasmol.js, line 131 Returns: name array to get Type Array.&lt;String&gt; &lt;static&gt; loc(loc) loc setter Parameters: Name Type Description loc Array.&lt;String&gt; loc array to set Source: SASMOL JS/sasmol.js, line 138 &lt;static&gt; getLoc() loc getter Source: SASMOL JS/sasmol.js, line 145 Returns: loc array to set Type Array.&lt;String&gt; &lt;static&gt; resname(resname) resname setter Parameters: Name Type Description resname Array.&lt;String&gt; resname array to set Source: SASMOL JS/sasmol.js, line 152 &lt;static&gt; getResname() resname getter Source: SASMOL JS/sasmol.js, line 159 Returns: resname array to get Type Array.&lt;String&gt; &lt;static&gt; chain(chain) chain setter Parameters: Name Type Description chain Array.&lt;String&gt; chain id array to set Source: SASMOL JS/sasmol.js, line 166 &lt;static&gt; getChain() chain getter Source: SASMOL JS/sasmol.js, line 173 Returns: chain id array to get Type Array.&lt;String&gt; &lt;static&gt; resID(id) resID setter Parameters: Name Type Description id Array.&lt;Number&gt; res id array to set Source: SASMOL JS/sasmol.js, line 180 &lt;static&gt; getResID() resID getter Source: SASMOL JS/sasmol.js, line 187 Returns: res id array to get Type Array.&lt;Number&gt; &lt;static&gt; rescode(rescode) rescode setter Parameters: Name Type Description rescode Array.&lt;String&gt; rescode array to set Source: SASMOL JS/sasmol.js, line 194 &lt;static&gt; getRescode() rescode getter Source: SASMOL JS/sasmol.js, line 201 Returns: rescode rescode array to get Type Array.&lt;String&gt; &lt;static&gt; coor(coor) coor setter Parameters: Name Type Description coor Object coor array to set Source: SASMOL JS/sasmol.js, line 208 &lt;static&gt; getCoor() coor getter Source: SASMOL JS/sasmol.js, line 215 Returns: coor array to get Type Object &lt;static&gt; coorObj(coorObj) coorObj setter Parameters: Name Type Description coorObj Object coorObj array to set Source: SASMOL JS/sasmol.js, line 222 &lt;static&gt; getCoorObj() coorObj getter Source: SASMOL JS/sasmol.js, line 229 Returns: coorObj array to get Type Object &lt;static&gt; occupancy(occupancy) occupancy setter Parameters: Name Type Description occupancy Array.&lt;Number&gt; occupancy array to set Source: SASMOL JS/sasmol.js, line 236 &lt;static&gt; getOccupancy() occupancy getter Source: SASMOL JS/sasmol.js, line 243 Returns: occupancy array to get Type Array.&lt;Number&gt; &lt;static&gt; beta(beta) beta setter Parameters: Name Type Description beta Array.&lt;Number&gt; beta array to set Source: SASMOL JS/sasmol.js, line 250 &lt;static&gt; getBeta() beta getter Source: SASMOL JS/sasmol.js, line 257 Returns: beta beta array to get Type Array.&lt;Number&gt; &lt;static&gt; elt(elt) elt setter Parameters: Name Type Description elt Array.&lt;String&gt; elt array to set Source: SASMOL JS/sasmol.js, line 264 &lt;static&gt; getElt() elt getter Source: SASMOL JS/sasmol.js, line 271 Returns: elt array to get Type Array.&lt;String&gt; &lt;static&gt; charge(charge) charge setter Parameters: Name Type Description charge Array.&lt;String&gt; charge array to set Source: SASMOL JS/sasmol.js, line 278 &lt;static&gt; getCharge() charge getter Source: SASMOL JS/sasmol.js, line 285 Returns: charge array to get Type Array.&lt;String&gt; &lt;static&gt; segname(segname) segname setter Parameters: Name Type Description segname Array.&lt;String&gt; segname array to set Source: SASMOL JS/sasmol.js, line 293 &lt;static&gt; getSegname() segname getter Source: SASMOL JS/sasmol.js, line 300 Returns: segname array to get Type Array.&lt;String&gt; &lt;static&gt; readPDB(inputStr) Reads PDB Asynchronously Parameters: Name Type Description inputStr string file Source: SASMOL JS/sasmol.js, line 311 Returns: full file as string Type string &lt;static&gt; writePDB() writes PDB (not to file, but returns string) Source: SASMOL JS/sasmol.js, line 441 Returns: full file as string Type string × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"module-JSSSE.html":{"id":"module-JSSSE.html","title":"Module: JSSSE","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Module: JSSSE Source: jssse.js, line 4 Namespaces bobj sobj jssse × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"module-JSSSE-bobj.html":{"id":"module-JSSSE-bobj.html","title":"Namespace: bobj","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: bobj JSSSE~ bobj bobj definition (doesn't really matter what values are initialized to the fields because everything is loosely defined in JS) Properties: Name Type Description id string value passed to jssse.createBoard() and used as the parent DOM element for display columns number number of sobjs to display per row sobjs Array.&lt;sobj&gt; collection of references of child sobjs events Array.&lt;event&gt; the array of pending events undo Array.&lt;event&gt; the array of events used for undo and redo undoPos number position of current state in undo array busy boolean set if events are processing sobjIndex number index of sobj to be created (next) Source: jssse.js, line 23 × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"module-JSSSE-sobj.html":{"id":"module-JSSSE-sobj.html","title":"Namespace: sobj","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: sobj JSSSE~ sobj sobj definition Properties: Name Type Description id string id value passed to jssse.createSobj() and used internally to keep track of the structure object source string loaded source tag from last jssse.load() data Object internal representation of structure data valid bool set to true if the load is complete bobj bobj references parent bobj options Object current options sasmol SasMol attached sasmol object Source: jssse.js, line 46 × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"module-JSSSE-jssse.html":{"id":"module-JSSSE-jssse.html","title":"Namespace: jssse","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: jssse JSSSE~ jssse JSSSE Object definition Source: jssse.js, line 59 Methods &lt;static&gt; remove(bobj) removes a bobj Parameters: Name Type Description bobj bobj a bobj previously returned form bojb.createBoard Source: jssse.js, line 90 &lt;static&gt; undo(bobj, n, cb) undoes operations in the undo/redo stack Parameters: Name Type Description bobj bobj the bobj to be operated on, returned previously from a jssse.createBoard() call n number optional number of steps to undo, 1 default, -1 undo to beginning cb function callback when operation is complete, returns err if undo count n is more than available Source: jssse.js, line 100 &lt;static&gt; redo(bobj, n, cb) redoes operations in the undo/redo stack Parameters: Name Type Description bobj bobj the bobj to be operated on, returned previously from a jssse.createBoard() call n number optional number of steps to redo, 1 default, -1 redo to beginning cb function callback when operation is complete, returns err if redo count n is more than available Source: jssse.js, line 109 &lt;static&gt; newEvent(bobj, eventObj) internal function to add an event to event stack (stored in sobj, separate from undo/redo stack) called by every event (mouse click, text entry etc) pushes eventObj to the bobj event stack and the undo/redo stack of bobj (as identified in eventObj) calls jssse.processEvents( bobj ) Parameters: Name Type Description bobj bobj the bobj to be operated on, returned from a jssse.createBoard() call eventObj event object produced by event handler Properties: Name Type Description sobj sobj the sobj for the event type string the type of event: select, remove, edit ?? canUndo boolean set if this event causes a change which can be undone (optional) selected Array.&lt;HTML_NODE&gt; required types: select, remove ?? undo boolean set by jssse.undo() to specify events that are to be undone cb function call back function when event is finished, called with ( err, eventObj ) Source: jssse.js, line 126 &lt;static&gt; processEvents(bobj) internal function to process the event stack returns immediately if no unprocessed events present or if event processing flag is set marks object event processing flag process oldest event off event stack calls whatever is needed to handle the event, e.g. screen updates etc. when all callbacks complete, unmark object event processing flag, return jssse.processEvents( obj ) Parameters: Name Type Description bobj bobj the bobj to be operated on, returned from a jssse.createBoard() call Source: jssse.js, line 139 &lt;static&gt; toBdata(bobj) returns a complete object which can be saved with the complete state Parameters: Name Type Description bobj bobj bobj : the bobj to be operated on Source: jssse.js, line 148 Returns: bdata : a deep copy of the bobj suitable for saving Type bobj &lt;static&gt; loadBobj(id, bdata) loads data previously serialized and creates a new bobj Parameters: Name Type Description id string DOM id to create bobj bdata bobj bdata : a deep copy of a bobj previously returned from jssse.toBdata() Source: jssse.js, line 157 Returns: bobj: the bobj Type bobj &lt;static&gt; createSobj(bobj, id, options) creates a sobj object attached to the given bobj Parameters: Name Type Description bobj bobj a bobj previously returned from bobj.createBoard id id a unique DOM id for this sobj options Object an object with options as defined below Properties: Name Type Description readonly boolean flag to determine whether or not the sobj is editable Source: jssse.js, line 180 Returns: the sobj which will hold all the state info for this structure object Type sobj &lt;static&gt; update(sobj, options, cb) updates options in sobj - keep in mind merges, options altered by other windows, depth Parameters: Name Type Description sobj sobj an sobj previously returned from a jssse.createSobj() call options Object an object with option properties as defined in jssse.createSobj() above cb function [description] Source: jssse.js, line 198 &lt;static&gt; options(sobj) return options of sobj, likely just return sobj.options; Parameters: Name Type Description sobj sobj an sobj previously returned from a jssse.createSobj() call Source: jssse.js, line 206 Returns: options : the options object as defined in jssse.createSobj() Type Object &lt;static&gt; load(sobj, data, loadOptions, cb) loads the data into the object and displays Parameters: Name Type Description sobj sobj an sobj previously returned from a jssse.createSobj() call data string a PDB in text, or a PDB file reference, e.g. &quot;file://path/to/pdb&quot; or &quot;http://server/path/to/file&quot; or &quot;rcsb:1XYZ&quot; etc. loadOptions Object an optional object describing loadOptions as described below cb function callback function when load finishes or fails due to error Properties: Name Type Description type string the type of data, such as pdb, pdbx, ... Source: jssse.js, line 218 Returns: throw error? Type string &lt;static&gt; out(sobj, outOptions) returns the data (possibly edited by the user) in various formats Parameters: Name Type Description sobj sobj an sobj previously returned from a jssse.createSobj() call outOptions Object an optional object describing outOptions as described below Properties: Name Type Description type string the type of data, such as pdb, pdbx, ... Source: jssse.js, line 251 Returns: the data of the object in the specified format Type Object &lt;static&gt; build(sobj1, sobj2) returns new object after merging objects (variadic function). Be careful with options (??) Parameters: Name Type Description sobj1 sobj variable number of sobjs previously returned from jssse.createSobj() calls sobj2 sobj Source: jssse.js, line 265 Returns: new built sobj if successful, error if failure Type sobj &lt;static&gt; copy(sobj, n) returns an array of objects copied (new instances created with properties copied over) Parameters: Name Type Description sobj sobj an sobj to be copied, returned previously from a jssse.createSobj() call n number number times to be copied Source: jssse.js, line 279 Returns: array of newly named (new id'd) sobjs also associated with the parent bobj Type Array.&lt;sobj&gt; × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"-_anonymous_-populateWindows-sasmolInfoObj.html":{"id":"-_anonymous_-populateWindows-sasmolInfoObj.html","title":"Namespace: sasmolInfoObj","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: sasmolInfoObj sasmolInfoObj generic object passed as param to populateSasMolInfo Properties: Name Type Description title string title of sasmol field info string literal text of what to display (account for big files) Source: widgetJS.js, line 424 × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "},"-_anonymous_-initialize-seqObj.html":{"id":"-_anonymous_-initialize-seqObj.html","title":"Namespace: seqObj","body":" JSSSE Documentation Namespaces SasMol~SasMolJSSSE~bobjJSSSE~sobjJSSSE~jssse~populateWindows~sasmolInfoObj~initialize~seqObj Modules SasMolJSSSE Global newBobjtestSobjreadFile(file)readmultifileshandleReadpopulateWindowspopulateSasMolInfoinitializecreateDividermirrorupdateCurrSelectionupdateSelDisplayclearAllSelectioncalibrateDispgetKeyByValuegetObjectByValuedisplayLocatorgetIndexByWidthpopulateZoomDivgetPosition Namespace: seqObj seqObj MODULAR sequence object (as opposed to original method of embedding sasmol information inside DOM id's and using regex's to slice everywhere) Properties: Name Type Description sasAtom SasMol corresponding sasmol object dom_id String corresponding DOM id zoomed boolean boolean flag for detecting if elt is being zoomed on (currently UNUSED) selected boolean boolean flag for detecting if elt is selected (currently UNUSED) pdbIndex number corresponding sobjIndex zoomText String text to display when elt is being zoomed in on (currently atom name) seqObjArrIndex number index of seqObj inside parent seqObjArr Source: widgetJS.js, line 570 × Search results Close Documentation generated by JSDoc 3.5.5 on August 1st 2018, 10:00:40 pm using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
