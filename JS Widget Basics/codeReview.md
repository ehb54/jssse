## CODE REVIEW:
*I couldn't find a way for JSDoc to include another html/MD page so I've
linked the Code Review section from the official MD home page (can relocate in the future). I highly recommend going through this guide/rant(?!) thoroughly but a [TL;DR](#directions-forwardtldr) section is also available. Minimum understanding: HTML structure of widget, DragSelectJS API, widgetJS API (helper methods all in Global namespace tab)*

**legend:**

*stuff marked in italics are side comments*

<strong>*bold italics are pretty important comments*</strong>

### Overview:
1. Repository Directory Structure
1. Comprehensive Code Review
   1. File 1 - SasMol
   1. File 2 - JSSSE
   1. File 3 - WidgetJS
   1. Known Bugs + possible ideas for solutions
1. Afterthoughts + Directions Forward

#### **REPOSITORY DIRECTORY STRUCTURE**

Tree structure generated by Linux tree using command:
```
tree -I 'bower_components|node_modules|fonts|styles' > tree.txt
```
-I flag ignores huge folders like bower_components, node_modules, and fonts + scripts files outputted by JSDOC/bootstrap

<details><summary>Collapsible Tree</summary>
<p>

```
.
├── docs
│   ├── -_anonymous_-initialize-seqObj.html
│   ├── -_anonymous_-populateWindows-sasmolInfoObj.html
│   ├── bobj.html
│   ├── global.html
│   ├── img
│   │   ├── glyphicons-halflings.png
│   │   └── glyphicons-halflings-white.png
│   ├── index.html
│   ├── jssse.html
│   ├── jssse.js.html
│   ├── module-JSSSE-bobj.html
│   ├── module-JSSSE.html
│   ├── module-JSSSE-jssse.html
│   ├── module-JSSSE-sobj.html
│   ├── module-SasMol.html
│   ├── module-SasMol-SasMol.html
│   ├── modules.list.html
│   ├── namespaces.list.html
│   ├── quicksearch.html
│   ├── SASMOL JS_sasmol.js.html
│   ├── scripts
│   │   ├── docstrap.lib.js
│   │   ├── fulltext-search.js
│   │   ├── fulltext-search-ui.js
│   │   ├── linenumber.js
│   │   ├── lunr.min.js
│   │   ├── prettify
│   │   │   ├── Apache-License-2.0.txt
│   │   │   ├── jquery.min.js
│   │   │   ├── lang-css.js
│   │   │   └── prettify.js
│   │   ├── sunlight.js
│   │   └── toc.js
│   ├── sobj.html
│   └── widgetJS.js.html
├── images
│   ├── bug1_IncorrectSplitSelection.png
│   └── joseph_notes1.jpg
├── JS Widget Basics
│   ├── bundle.js
│   ├── conf.json
│   ├── docIndex.md
│   ├── Drafts&Subprojects
│   │   ├── arrDispArrTest.js
│   │   ├── bundle.js
│   │   ├── index.html
│   │   ├── javascript.js
│   │   ├── oldCSS.css
│   │   ├── oldDragSelect.js
│   │   ├── oldIndex.html
│   │   ├── Sequence Object Redesign
│   │   │   ├── bundle
│   │   │   ├── bundle.js
│   │   │   ├── index.html
│   │   │   ├── javascript.js
│   │   │   └── style.css
│   │   ├── Sequence Selector Draft 1
│   │   │   ├── index_draft1.html
│   │   │   ├── javascript_draft1.js
│   │   │   └── style_draft1.css
│   │   ├── style.css
│   │   └── workingDemo.js
│   ├── DragSelect.js
│   ├── High Level Tests
│   │   ├── canvasPlanCSS.css
│   │   ├── canvasPlan.html
│   │   ├── canvasPlanJS.js
│   │   ├── conf.json
│   │   ├── module1.js
│   │   ├── testDrag2.js
│   │   ├── testDragCSS.css
│   │   ├── testDrag.html
│   │   ├── testDragJS.js
│   │   ├── testFileMultiRead.js
│   │   ├── testFileReadIndex.html
│   │   ├── testjsdoc.js
│   │   └── testOut
│   │       ├── global.html
│   │       ├── index.html
│   │       ├── module1.js.html
│   │       ├── module-A.html
│   │       ├── module-Obj.html
│   │       ├── module-Person.html
│   │       ├── module-Person-Person.html
│   │       ├── module-testJSDOC.html
│   │       ├── scripts
│   │       │   ├── linenumber.js
│   │       │   └── prettify
│   │       │       ├── Apache-License-2.0.txt
│   │       │       ├── lang-css.js
│   │       │       └── prettify.js
│   │       └── testjsdoc.js.html
│   ├── jspdb.js
│   ├── jssse.js
│   ├── package.json
│   ├── package-lock.json
│   ├── readFiles.js
│   ├── SASMOL JS
│   │   ├── 1AA-NoEND.pdb
│   │   ├── 1bdg.pdb
│   │   ├── 4ibc.pdb
│   │   ├── 6djx.pdb
│   │   ├── drafts
│   │   │   ├── bundle.js
│   │   │   ├── index.html
│   │   │   ├── sasioDraft2.js
│   │   │   ├── sasioDraft.js
│   │   │   ├── sasmolDraft.js
│   │   │   └── scripts
│   │   │       ├── main.js
│   │   │       ├── objects.js
│   │   │       ├── require.js
│   │   │       └── testRequire1.js
│   │   ├── numjs
│   │   ├── numjstest.js
│   │   ├── pdbDebug.pdb
│   │   ├── res.pdb
│   │   ├── sasIndex.html
│   │   ├── sasio.js
│   │   ├── sasmol-bundle.js
│   │   ├── sasmol.js
│   │   ├── sasmol.py
│   │   ├── sasmol.pyc
│   │   ├── sprintfTest.js
│   │   ├── system.py
│   │   └── test.py
│   ├── server.js
│   ├── test.txt
│   ├── widget.html
│   ├── widgetJS.js
│   └── widgetStyle.css
├── README.md
├── SASMOL JS
│   ├── sasIndex.html
│   ├── sasio.js
│   ├── sasmol-bundle.js
│   └── sasmol.js
├── testing
│   └── events.js
└── tree.txt

18 directories, 123 files
```

</p>
</details>

/Directories and Files in Root (**final design path marked in bold**, excludes files needed for JSDoc):
1. /Doc - holds necessary HTML/js files for the documentation website generated by JSDoc/Bootstrap
1. /Images - pictures used in poster, pictures used in this code review, misc. pics
1. **/JS Widget Basics** - contains meat of code
   1. **Bower_components** - jQuery files
   1. Drafts&Subprojects - folder containing drafts of the main HTML/JS files that I worked with before copying over to widgetJS + widget.html. (lazy version control basically) For those who are curious:
      1. /Sequence Selector Draft 1 - has initial design of dragselect before discovering an established version online.
      1. /Sequence Object Redesign - contains drafts working with the seqObj dilemma I dealt with (vs regex embedded dom id's).
   1. High Level Tests - HTML/JS for initial canvas design, working with CSS Grid design, etc. Also contains unit tests for corresponding dragSelect, multiple file read before implementing into 'final' design
     1. Test Drag files - unit tests to ensure that selection in one box gets 'mirrored' in the other (essential for zoomdiv and main sequence div)
     1. /testOut - output of running JSDoc on some test JS files to make sure modules were being correctly documented in the final HTML output.
     1. readFile.js - initial testing for file reading
     1. server.js - file for learning about nodeJS server setup
   1. **Node_modules** - nodejs modules
      - (**_For the final design, it may be good to consider moving used raw NodeJS modules into the main directory. However, this may be difficult if a module uses other modules (numjs maybe). In this case, it is probably best to use 'browserify' to automatically bundle everything_**)
   1. **bundle.js** - 'browserified' widgetJS.js (explanation for browserify in comprehensive code review)
   1. conf.json - configuration file for JSDoc
   1. docIndex.md - markdown file for main documentation page generated by JSDoc
   1. **DragSelect.js** - DragSelectJS module copied from Node_modules
   1. jspdb.js - old draft of JSSSE definition (before being renamed)
   1. **jssse.js** - definition for JSSSE, bobj, sobj namespaces + related methods
   1. **widget.html** - HTML file for widget
   1. **widgetJS.js** - JS file for widget, works with HTML generation and widget-related events
   1. **widgetCSS.css** - CSS file for styling the HTML
1. /SASMOL JS - contains SasMol, Sasio (**_DEPRECATED_**), and SasIndex (used for debugging outputs of sasmol/sasio)
   - (**_For reasons explained later, SasMol is the only important file in this directory - it should be relocated to the main directory with all of the widget definitions for optimization purposes to avoid confusion with organization if things somehow get moved around_**)
1. /Testing - Prof. Brookes's testing files with events + undo/redo
1. README.md - markdown page for github repo - should probably be updated
1. tree.txt - output tree file


#### COMPREHENSIVE CODE REVIEW
**Background:**

**SasMol** is a class first delineated by Dr. Curtis in Python. Its junior version in JS here only parses ATOM records in PDB's. Functionality should be extended to accommodate different file formats and more PDB records. As of now, SasMol (js) contains both the class definition AND the methods for parsing the PDB in the same file (as opposed to separate sasmol and sasio in python). This is why SasMol is the only important file in the 'SASMOL JS' folder.
   - _Adding support for more records should simply be a matter of emulating the regex parsing method. Different file formats require more expertise_

**JSSSE** contains definitions and methods for the JSSSE, bobj, sobj namespaces. They are based off of API v0.2 on the Github Repo.

**WidgetJS** contains all of the HTML generation and widget-related events.

The 3 main JS files listed above should be well documented with JSDoc/Bootstrap. JSDoc API is also easy to understand. _Shortcut for Github's Atom editor for generating JSDoc headers is to type '/**' + TAB_. Run with:
```
jsdoc -c ./conf.json -d ../docs -R ./docIndex.md -t ./node_modules/ink-docstrap/template
```
In final implementation, **_consider moving ink-doctrap/template folder for reorganization_**

1. **SasMol** - I've tried my best to emulate the style in the Python counterpart.
   - As more PDB Records are accounted for, I assume the currently undefined data properties (index, original_index, moltype, conect, residue_flag, original_resid, header) will be fixed up or removed.
   - Currently, readPDB and writePDB only deal with string inputs as suggested by Prof. Brookes. In older drafts, I experimented with using NodeJS fs and a npm module (readline) for reading a file line by line but since this will most likely be done in the browser, string I/O is the way to go.
   - The vsprintf module is pretty neat to use (formats strings using identifiers, etc) so I was able to implement Dr. Curtis's specifiers with success. It's probably useful for printing other records.
   - **_The only trouble I had with following the Python SasMol part was the coor part. I could easily populate the numjs coor nd array but I couldn't figure out how to use analogous python methods for slicing it to retrieve the contents in a meaningful way (I believe numjs only allows elt-by-elt slicing, not row). So I resorted to using a simple object definition like so: coor: {x: blah, y: blah, z: blah} since populating it and accessing it is trivial (I don't know about the overhead, efficiency, etc)._**
1. **JSSSE** - the definitions and related methods are pretty well-defined in the API. Sidenotes will only be mentioned here.
   - Is JSSSE supposed to have properties? I've left them empty for now.
   - I've added a 'sobjIndex' property for keeping track of sobj generation and position of most recently added sobj in the sobjs array. (ex: at start, the index is 0. Everytime a new sobj is created, increment the index so the next sobj can be assigned to the correct index in the array (as opposed to using array.push()). Likewise, everytime sobj is removed, decrement the index so you are always keeping track of the position). *There may be better ways of doing this.*
   - I've added a 'sasmol' property for sObj because I felt it was necessary to keep track of PDB information while conveniently using a namespace we had already defined.
   - **_It may be good to move all PDB reading event related code into this file. Currently, the WidgetJS.js file handles when the reading when the 'Read PDB(s)' button is pressed (creates SasMol object, calls SasMol.readPDB to populate the SasMol, and assigns populated SasMol to sobj.sasmol field)_**.
   - I assume fields like loadOptions and various other 'options' objects will be better defined as more code is written
1. **WidgetJS** - the whole file can be generally divided into:  JSSSE + SasMol definitions in Main, Developer code, and Helper Methods. **It is paramount to understand how the widget HTML is structured before looking at how the elements are brought into existence + related events for handling what/when boxes appear, etc in this file. Editing existing stuff in the HTML requires careful consideration of what also gets changed in the JS file. Also review [DragSelectJS API](https://thibaultjanbeyer.github.io/DragSelect/) to save time code-reading**
   - _Disclaimer: There are many ways for simplifying JS using the jQuery $ operator. Immediate examples that come to mind are DOM traversals ex: $('.class') instead of document.getElementsByClassName('class') and other methods like $('.class').remove() vs accessing parent node and looping through the HTML child node collection and calling removeChild()._
   - **JSSSE + SasMol definitions in Main:**
       - handles 'read PDB(s)' button click event. Triggers reading functions which then populate the sasmol + sobj.sasmol field
      - contains examples for how to create sobj objects, sasmol objects, bobj objects in main.
   - **Developer code**
      - _I've thought over how to handle multiple pdb + sobj loading for a while and one way to go about it is to keep track of a global sobjIndex variable that you use to access DOM elements unique to each sobj. Then, while you are dynamically creating HTML elements, you can push them into arrays and access them using the global sobjIndex variable (or alternatively, using the document.getElementsByClassName('class')[sobjIndex] way since keeping track of all of the arrays becomes unwieldy especially with many nested HTML elements). Prof. Brookes introduced an idea about managing things at the top level bobj element but_ **_this aspect clearly requires more thought_**
         - populateWindows( ... ) gets called to generate the skeleton of the widget - this does not include the residues and related selection functionalities. This method also populates the PDB memory box and PDB contents inside the sobj window (toggle-able properties like SEGNAME, beta, etc)
         - More fine-tuning is needed for populating the pdb memory box. This most likely requires support for more PDB records (MODELS?) to populate the CHAINS HTML unordered list element (ul). Furthermore, making the list elements (li) collapsible would be pretty nice but also keep in mind the size of the pdb. _*Consider emulating how large elements are displayed in Chrome Developer Tools - it gets (dynamically?) subdivided into segments. ex: 0-99, 100-199, etc. This can be seen after uncommenting a console.log(seqObjArr) statement.*_
         - the PDB contents inside the sobj window also need some fine-tuning as to what gets displayed. _Selection only? First 10 and last 10? Just first and last? For now, I have it at first ... last, similar to how it is done in the PDB memory box._
         - The update button logic (early stages of development) now creates draggable or in jQuery terms 'droppable' element to the build canvas. _The HTML gets wonky when positioning of other divs in the sobj get moved around ex: zoom or toggling div)_
         - **_HTML part of the sobj content divs are absolutely positioned so they are assigned pixels from top. This is because the widget Container is also absolutely positioned so the seqObjs get displayed correctly (otherwise they get shifted right, this can be seen by playing with Chrome Dev Tools)_**
    - initialize( ... ) engenders functionality within the sequence div - allowing selection, events to track cursor hovering in real-time, zooming, etc. See how to define a seqObj in this section of the code. Its properties are modular _(right now, zoomed and selected are unused because I was afraid of clobbering the already well-established selection logic)_. Properties like seqObjArrIndex should be pretty straightforward for understanding how to keep track of the elt in the grand scheme. However, there may be better ways of structuring this. SeqObj's and the DragSelect Objects are the main takeaways here - events associated with the DragSelect Objects call upon helper functions to do the 'magic'.
       - createDividers() has some rudimentary logic, _consider redesigning it for responsiveness, etc_. _I didn't research how to represent tickmarks conventionally, etc. The way it's done in the nice NCBI widget is to overlay a pre-made image of a canvas so they basically had other software generate that part instead of doing it on the fly_.
   - **Helper Methods**
      - all methods are pretty well documented in the API generated by JSDoc and contain comments on their own. **_Most take in sobjIndex as a parameter, so if the multiple sObj idea gets changed, then many of these helper functions may ahve to be rewritten to ensure that the right HTML elements get altered._**
      - **_using getObjectByValue is risky if two fields of seqObj may potentially have the same value. So it is unadvisable to use it with Booleans, and other numeric values._** As of now, I use it on the only numeric field seqObjArrIndex. (previously, I included several SasMol fields into the seqObj, but making a linked SasMol field eliminates this issue).
      - populateZoomDiv( ... ) does what the name implies. **_It should be made more modular if the user wants to increase the range allowed by the zoom. Consider adding a simple dropdown with values 5, 10, 15._**
      - getIndexByWidth( ... ) does some very rudimentary geometric calculations and populates the value inside the locatorBox. **_Consider fine-tuning this logic. For average-sized pdb's ranging in the thousands, there may not be any better way to track mouse hovering over the seqObj's than a simple geometric calculation_**.
      - other methods such as updateSelDisplay, updateCurrSelection, calibrateDisp, clearAllSelection concern the sequence Feedback box. Key functionalities include splitting selection into coherent and contiguous subarrays. (ex: selection may look like this [1, 2, 3, 5, 6, 8, 10] which should logically look like this: [1-3, 5-8, 10])

**KNOWN BUGS + POSSIBLE IDEAS FOR SOLUTIONS + TEMPORARY WORKAROUNDS**
1. selecting in the primary sequence div for average pdb's incorrectly splits selection array into a single element + array. Refer to  [picture](https://github.com/ehb54/jssse/tree/master/images/bug1_IncorrectSplitSelection.png)
   - Sol'n: ?
1. While SHIFT is held to zoom, CTRL toggles zoom Div off.
   - Possible Explanation: the eventlistener for keyup does not know which key has been lifted up
   - Workaround: CTRL after MOUSEDOWN + selecting a range
   - Solution: introduce boolean flags to differentiate between CTRL and SHIFT?
1. Selecting in the Zoom Div while there is already a selection does not cancel the selection. Standard logic for the DragSelect module holds that a MOUSEDOWN + drag without holding a multi-select key (currently only CTRL) cancels all current selections (works in primary seq Div as opposed to Zoom Div).
   - Possible Explanation: mirror( ... ) method is probably responsible for this.
1. Marker doesn't accurately track hovered-over element (bug is not reproducible for smaller PDB's)
   - Possible Explanation: the getIndexByWidth method may not use correct width (getBoundingClientRect? vs offsetLeft?)
1. In Safari, user is able to select any text (especially dividers + zoomed text). First block in CSS for styling the .body{ } somehow does not account for this...
   - Sol'n: ? Check if browser supported?
1. If you mess around with the CSS grid-templates-areas property (removing sobj from HTML, adding dynamically, etc), things look very wonky _(I don't think I understand CSS grid very well, however)_
   - Sol'n: Do some high-level tests with simple grid and dynamically adding elements
1. More? document here...

#### **AFTERTHOUGHTS + DIRECTIONS FORWARD**
##### **DIRECTIONS FORWARD/TL;DR**
(written like instructions to myself on how I would do it if I had more time, so take no offense if the language seems blunt)
Assuming the current state of the code will be built on:
- Make sure CSS Grid works at a High level + generating HTML for sub-windows (probably use JS .gridTemplateAreas = 'blah')
- Be careful when bringing scripts together in the HTML file (browserify). Variables in an early defined script cannot be called inside the document.ready() (or $(function({ }))) code block of any subsequent script - _I've tried this but I may be wrong_. Unfortunately, the document.ready()/$(function({})) is almost always required if there is existing HTML. Even if there just ends up being a button for reading in PDB, you still need to wait until the document is ready to attach the event listener to actually start reading the PDB _(or dynamically generate starting button?)._
- Figure out a reliable way for keeping track of sobj's and stick with it - whether it be sobjIndex or in the parent bobj.
- Add ReadPDB functionality for parsing CHAIN/MODEL information for below step:
- Agree on what to display for the toggle-able information divs and the pdb memory - consider looking at how Chrome Dev Tools displays large arrays as an example.
- Decide how to represent the assembly of sobjs. Literal mashing of arrays in properties?
   - Clean up jQuery 'droppable' functionality when 'update' is clicked (in WidgetJS populateWindows( ... ) method)
- Move towards integrating the CSS properties with the dynamic HTML generation done in JS. Major edits to the hard-coded geometric properties can clobber a lot of the functionality if done carelessly. (Traditional web dev as I've learned from scouring the web does include some sort of work with CSS but I now realize that our scientific application requires as much dynamic processing as possible so it should be JS>CSS>HTML)
- Introduce more buttons and decide on functionality


##### **AFTERTHOUGHTS**
- Hopefully this guide was a bit helpful for understanding the thought process of my code. Most of this seems like rambling from a quick glance but words are the easiest way for me explain since there are some nuances that can't quite be explained simply by looking at the raw code. I wish I had more expertise to go further into the project - turns out the Drag Select functionality was not as easy as I had anticipated and took up most of my time xD
- As a memorandum for when I need to reflect back on this internship, here are the main points that I've internalized (technical and non-technical):
   - Software development - start with high-level design and break the problem down into manageable pieces. Don't spend too long on a piece. When you don't know how something will turn out, try it at a high level.
      - JavaScript
         - JSDoc + Docstrap streamlines documentation really well
         - Everything is basically an Object (arrays don't even exist!)... which makes abstract design pretty fun
         - Variables are loosely defined - you can declare one type and change the type later
         - There is no conventional OOP inheritance, you can mimic classes with Object_prototype chaining but that hurts to think about... ECMAScript 2015 Classes wrap up prototype-based inheritance pretty nicely to match the conventional model.
         - NodeJS has tons of nifty modules
         - Things to explore further: how exporting, requiring, importing modules work, how to use other JS frameworks like Meteor, React, Angular
      - HTML
         - Github Markup is fun to use
      - CSS
         - Check out SCSS for bringing in some *actual* programming to CSS
         - CSS grid is neat
      - Python
         - don't end lines with semicolons, separate by indenting
         - code like you speak and it will probably work...
         - numpy is magic
      - Networking
         - Basic https requests + TCP/IP protocol
         - why AJAX and anything async matters (running other code before callbacks execute) + a little about Promises.
         - Next step for me: understand OSI model front-to-back (useful in embedded applications), tinker with wireshark and network stuff on Pi
   - General behavior in professional environment
      - Ask when questions arise immediately, ask for clarification if needed ASAP. Most of the time, I struggle with not knowing what I don't understand so I sometimes blindly approach a problem and code myself into a corner. Leading to...
      - Gather thoughts before tackling a problem. Consider making a high-level list of things to accomplish
